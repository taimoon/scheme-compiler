(import
  (only (desugar) write-primitive-lib)
  (only (front) preprocess)
  (only (match) match)
  (only (set) make-set set-union set-diff)
  (only (utils)
    make-env extend-env maybe-apply-env apply-env
    read-sexps-from-path align-to-multiple
    random-string symbol->id-symbol string->id-string generate-label
    system*
    path-fileroot path-filename mk-tmpname))

(let ()
;;; TODO: aligned stack frame layout like what have been done in x86
;;; REFERNECE: RISC-V ELF psABI
; https://lists.riscv.org/g/tech-psabi/attachment/61/0/riscv-abi.pdf
; https://riscv.org/wp-content/uploads/2024/12/riscv-calling.pdf

(define REGISTERS '(a0 a1 a2 a3 a4 a5 a6 a7))
(define FIXNUM-MASK   #b00000111)
(define FIXNUM-TAG    #b00000000)
(define FIXNUM-SHIFT  3)
(define IMM-SHIFT     8)
(define IMM-MASK      #b11111111)
(define IMM-TAG       #b00000111)
(define EOF-TAG       #b00000111)
(define CHAR-TAG      #b00001111)
(define BOOL-TAG      #b00011111)
(define NIL-TAG       #b00111111)
(define FALSE-IMM     BOOL-TAG)
(define TRUE-IMM      (bitwise-ior (ash 1 IMM-SHIFT) BOOL-TAG))
(define PTR-MASK      #b00000111)
(define PAIR-TAG      #b00000001)
(define VEC-TAG       #b00000010)
(define STR-TAG       #b00000011)
(define SYM-TAG       #b00000101)
(define CLOS-TAG      #b00000110)
(define GC-CTX-MIN-SIZE 64)
(define (maybe-getenv name default)
  (let ((val (getenv name)))
    (if val val default)))
(define CC (maybe-getenv "CC" "gcc"))
; -march=rv64gc_zbb support cound leading zero instructions
(define CC-ARGS "-g -fno-omit-frame-pointer -march=rv64gc_zbb")
(define OBJCOPY (maybe-getenv "OBJCOPY" "objcopy"))

(define WORDSIZE 8)
(define CLOS-REG "s1")
(define AP-REG "s2")

;;; emit
(define (emit op . args)
  (apply format (cons op args))
  (newline op))

(define (immediate? v)
  (or (integer? v) (boolean? v) (char? v)))

(define (immediate-rep imm)
  (cond
    ((char? imm)
     (bitwise-ior CHAR-TAG
                  (ash (char->integer imm)
                       IMM-SHIFT)))
    ((boolean? imm)
     (if imm TRUE-IMM FALSE-IMM))
    ((integer? imm)
     (ash imm FIXNUM-SHIFT))
    ((null? imm)
     NIL-TAG)
    (else (error "immediate-rep" "unknown immediate" imm))))

(define (emit-eax=? op v)
  (emit op "li t0, ~a" v)
  (emit op "sub t0, a0, t0")
  (emit op "seqz t0, t0")
  (emit op "slli t0, t0, ~a" IMM-SHIFT)
  (emit op "ori a0, t0, ~a" BOOL-TAG))

(define (emit-cmp op cmp e1 e2 si env)
  (emit-simple op e1 'a0)
  (emit-simple op e2 'a1)
  (cond
    ((eq? cmp '<)
     (emit op "slt a0, a0, a1"))
    ((eq? cmp '=)
     (emit op "sub t0, a0, a1")
     (emit op "seqz a0, t0"))
    ((eq? cmp 'eq?)
     (emit op "sub t0, a0, a1")
     (emit op "seqz a0, t0"))
    ((eq? cmp '<=)
     (emit op "sub t0, a0, a1")
     (emit op "seqz t0, t0")
     (emit op "slt t1, a0, a1")
     (emit op "or a0, t0, t1"))
    ((eq? cmp '>)
     (emit op "sub t0, a0, a1")
     (emit op "sgtz a0, t0"))
    ((eq? cmp '>=)
     (emit op "sub t0, a0, a1")
     (emit op "seqz t1, t0")
     (emit op "sgtz t2, t0")
     (emit op "or a0, t1, t2")))
  (emit op "slli a0, a0, ~a" IMM-SHIFT)
  (emit op "ori a0, a0, ~a" BOOL-TAG))

(define (emit-if op pred conseq altern si env)
  (let ((end-label (generate-label "end"))
        (altern-label (generate-label "altern")))
    (emit-expr op pred si env)
    (emit op "li t0, ~a" FALSE-IMM)
    (emit op "beq a0, t0, ~a" altern-label)
    ;;; NOTE: for debugging purpose
    (emit op "~a :" (generate-label "conseq"))
    (emit-expr op conseq si env)
    (emit op "j ~a" end-label)
    (emit op "~a: " altern-label)
    (emit-expr op altern si env)
    (emit op "~a: " end-label)))

(define (emit-str-lit op s si)
  (emit op "mv t0, ~a" AP-REG)
  (emit op "li t1, ~a" (align-to-multiple 8 (+ WORDSIZE (+ 1 (string-length s)))))
  (emit op "add ~a, ~a, t1" AP-REG AP-REG)
  ;;; store string-length
  (emit op "li t1, ~a" (immediate-rep (string-length s)))
  (emit op "sd t1, 0(t0)")
  (for-each
    (lambda (i)
      (emit op "li t1, ~a" (char->integer (string-ref s i)))
      (emit op "sb t1, ~a(t0)" (+ WORDSIZE i)))
    (iota (string-length s)))
  (emit op "sb x0, ~a(t0)" (+ WORDSIZE (string-length s)))
  (emit op "ori a0, t0, ~a" STR-TAG))

(define (emit-vector op es si env)
  ;;; es are list of atomized subexpression
  (let ((sz (length es)))
    (emit op "mv a0, ~a" AP-REG)
    (emit op "add ~a, ~a, ~a" AP-REG AP-REG (align-to-multiple 8 (* (+ sz 1) WORDSIZE)))
    (emit op "li t0, ~a" (immediate-rep sz))
    (emit op "sd t0, (a0)")
    (for-each
      (lambda (i e)
        (emit-simple op e 'a1)
        (emit op "sd a1, ~a(a0)" (* (+ i 1) WORDSIZE)))
      (iota sz)
      es)
    (emit op "ori a0, a0, ~a" VEC-TAG)))

(define (store-to-label op src-reg dst-lbl)
  (emit op "la t0, ~a" dst-lbl)
  (emit op "sd ~a, 0(t0)" src-reg))

(define (load-from-label op dst-reg src-lbl)
  (emit op "la ~a, ~a" dst-reg src-lbl)
  (emit op "ld ~a, 0(~a)" dst-reg dst-reg))

(define (emit-simple op e dest)
  (match e
    (,()
     (guard (immediate? e))
     (emit op "li ~a, ~a" dest (immediate-rep e)))
    ((quote ())
     (emit op "li ~a, ~a" dest (immediate-rep '())))
    ((global ,lbl)
     (load-from-label op dest lbl))
    ((label ,lbl)
     (load-from-label op dest lbl))
    ((local-ref ,i)
     (guard (integer? i))
     (emit op "ld ~a, ~a(sp)" dest (* (- WORDSIZE) (+ i 2))))
    ;;; TODO: closure-ref shouldn't be simple
    ((closure-ref ,() ,i)
     (guard (integer? i))
     (emit op "mv ~a, ~a" dest CLOS-REG)
     (emit op "add ~a, ~a, ~a" dest dest (- (* WORDSIZE (+ i 2)) CLOS-TAG))
     (emit op "ld ~a, (~a)" dest dest))
    (,() (error "emit-simple" "unmatch" e))))

(define (emit-prim op e si env)
  (match e
    ((%walk-stack)
     (emit-walk-stack op -1 si env))
    ((%walk-stack ,e)
     (emit-walk-stack op e si env))
    ((align-to-multiple 8 ,e)
     (emit-simple op e 'a0)
     (emit op "addi a0, a0, ~a" (immediate-rep (- 8 1)))
     (emit op "andi a0, a0, ~a" (immediate-rep -8)))
    ((eof-object)
     (emit op "li a0, ~a" EOF-TAG))
    ((eof-object? ,e)
     (emit-simple op e 'a0)
     (emit op "andi a0, a0, ~a" IMM-MASK)
     (emit-eax=? op EOF-TAG))
    ((integer? ,e)
     (emit-simple op e 'a0)
     (emit op "andi a0, a0, ~a" FIXNUM-MASK)
     (emit-eax=? op FIXNUM-TAG))
    ((boolean? ,e)
     (emit-simple op e 'a0)
     (emit op "andi a0, a0, ~a" IMM-MASK)
     (emit-eax=? op BOOL-TAG))
    ((char? ,e)
     (emit-simple op e 'a0)
     (emit op "andi a0, a0, ~a" IMM-MASK)
     (emit-eax=? op CHAR-TAG))
    ((char->integer ,e)
     (emit-simple op e 'a0)
     (emit op "srai a0, a0, ~a" (- IMM-SHIFT FIXNUM-SHIFT)))
    ((integer->char ,e)
     (emit-simple op e 'a0)
     (emit op "slli a0, a0, ~a" (- IMM-SHIFT FIXNUM-SHIFT))
     (emit op "ori a0, a0, ~a" CHAR-TAG))
    ((,cmp ,e1 ,e2)
     (guard (memq cmp '(< <= eq? = >= >)))
     (emit-cmp op cmp e1 e2 si env))
    ((- ,e)
     (emit-simple op e 'a0)
     (emit op "neg a0, a0"))
    ((- ,e1 ,e2)
     (emit-simple op e2 'a1)
     (emit-simple op e1 'a0)
     (emit op "sub a0, a0, a1"))
    ((+ ,e1 ,e2)
     (emit-simple op e2 'a1)
     (emit-simple op e1 'a0)
     (emit op "add a0, a0, a1"))
    ((* ,e1 ,e2)
     (emit-simple op e2 'a1)
     (emit-simple op e1 'a0)
     (emit op "srai a0, a0, ~a" FIXNUM-SHIFT)
     (emit op "mul a0, a0, a1"))
    ((fixnum-width)
     (emit op "li a0, ~a" (immediate-rep (- (ash WORDSIZE 3) 3))))
    ((fxabs ,e)
     (emit-simple op e 'a0)
     (let ((altern (generate-label "fxabs_altern")))
      (emit op "bge a0, x0, ~a" altern)
      (emit op "neg a0, a0")
      (emit op "~a: " altern)))
    ((fxmax ,e1 ,e2)
     (emit-simple op e2 'a1)
     (emit-simple op e1 'a0)
     (let ((altern (generate-label "fxabs_altern")))
      (emit op "bge a0, a1, ~a" altern)
      (emit op "mv a0, a1")
      (emit op "~a: " altern)))
    ((fxlength ,e1)
     ;;; TODO: simplify this
     (emit-prim op `(fxabs ,e1) si env)
     (emit op "ori a0, a0, ~a" FIXNUM-MASK)
     (emit op "clz a0, a0")
     (emit op "neg a0, a0")
     (emit op "add a0, a0, ~a" (- (ash WORDSIZE 3) 3))
     (emit op "slli a0, a0, ~a" FIXNUM-SHIFT))
    ((div ,dividend ,divisor)
     #;((div (* t x) (* t y))
        => (div x y)
        => (tag (div x y)))
     (emit-simple op divisor 'a1)
     (emit-simple op dividend 'a0)
     (emit op "div a0, a0, a1")
     (emit op "slli a0, a0, ~a" FIXNUM-SHIFT))
    ((mod ,dividend ,divisor)
     ;;; TODO: don't know why this works?
     (emit-expr op divisor si env)
     (emit-simple op divisor 'a1)
     (emit-simple op dividend 'a0)
     (emit op "rem a0, a0, a1"))
    ((ashl ,e1 ,e2)
     (emit-simple op e2 'a1)
     (emit-simple op e1 'a0)
     (emit op "srai a1, a1, ~a" FIXNUM-SHIFT)
     (emit op "sll a0, a0, a1"))
    ((ashr ,e1 ,e2)
     (emit-simple op e2 'a1)
     (emit-simple op e1 'a0)
     (emit op "srai a1, a1, ~a" FIXNUM-SHIFT)
     (emit op "srai a0, a0, ~a" FIXNUM-SHIFT)
     (emit op "sra a0, a0, a1")
     (emit op "slli a0, a0, ~a" FIXNUM-SHIFT))
    ((bitwise-and ,e1 ,e2)
     (emit-simple op e2 'a1)
     (emit-simple op e1 'a0)
     (emit op "and a0, a0, a1"))
    ((bitwise-ior ,e1 ,e2)
     (emit-simple op e2 'a1)
     (emit-simple op e1 'a0)
     (emit op "or a0, a0, a1"))
    ((null? ,e)
     (emit-simple op e 'a0)
     (emit op "andi a0, a0, ~a" IMM-MASK)
     (emit-eax=? op NIL-TAG))
    ((pair? ,e)
     (emit-simple op e 'a0)
     (emit op "andi a0, a0, ~a" PTR-MASK)
     (emit-eax=? op PAIR-TAG))
    ((cons ,simp1 ,simp2)
     (emit op "mv a0, ~a" AP-REG)
     (emit op "addi ~a, ~a, ~a" AP-REG AP-REG (* 2 WORDSIZE))
     (emit-simple op simp1 'a1)
     (emit-simple op simp2 'a2)
     (emit op "sd a1, (a0)")
     (emit op "sd a2, ~a(a0)" WORDSIZE)
     (emit op "ori a0, a0, ~a" PAIR-TAG))
    ((car ,e)
     (emit-simple op e 'a0)
     (emit op "addi a0, a0, ~a" (- PAIR-TAG))
     (emit op "ld a0, (a0)"))
    ((cdr ,e)
     (emit-simple op e 'a0)
     (emit op "addi a0, a0, ~a" (- WORDSIZE PAIR-TAG))
     (emit op "ld a0, (a0)"))
    ((set-car! ,e ,v)
     (emit-simple op v 'a1)
     (emit-simple op e 'a0)
     (emit op "addi a0, a0, ~a" (- PAIR-TAG))
     (emit op "sd a1, (a0)"))
    ((set-cdr! ,e ,v)
     (emit-simple op v 'a1)
     (emit-simple op e 'a0)
     (emit op "addi a0, a0, ~a" (- WORDSIZE PAIR-TAG))
     (emit op "sd a1, (a0)"))
    ((string? ,e)
     (emit-simple op e 'a0)
     (emit op "andi a0, a0, ~a" PTR-MASK)
     (emit-eax=? op STR-TAG))
    ((make-string ,sz ,ch)
     (store-to-label op AP-REG 'free_ptr)
     (emit-foreign-call op 's_make_string (list sz ch) si env)
     (load-from-label op AP-REG 'free_ptr))
    ((string-length ,s)
     (emit-simple op s 'a0)
     (emit op "add a0, a0, ~a" (- STR-TAG))
     (emit op "ld a0, (a0)"))
    ((string-set! ,s ,i ,v)
     (emit-simple op s 'a0)
     (emit-simple op i 'a1)
     (emit op "srai a1, a1, ~a" FIXNUM-SHIFT) ; remove fixnum mask
     (emit-simple op v 'a2)
     (emit op "srai a2, a2, ~a" IMM-SHIFT) ; remove char mask
     (emit op "addi a0, a0, ~a" (- WORDSIZE STR-TAG))
     (emit op "add a0, a0, a1")
     (emit op "sb a2, (a0)")
     (emit op "mv a0, x0"))
    ((string-ref ,s ,i)
     (emit-simple op s 'a0)
     (emit-simple op i 'a1)
     (emit op "srai a1, a1, ~a" FIXNUM-SHIFT) ; remove fixnum mask
     (emit op "addi a0, a0, ~a" (- WORDSIZE STR-TAG))
     (emit op "add a0, a0, a1")
     (emit op "lb a0, (a0)")
     (emit op "slli a0, a0, ~a" IMM-SHIFT)
     (emit op "ori a0, a0, ~a" CHAR-TAG))
    ((vector? ,e)
     (emit-simple op e 'a0)
     (emit op "andi a0, a0, ~a" PTR-MASK)
     (emit-eax=? op VEC-TAG))
    ((vector . ,es)
     (emit-vector op es si env))
    ((vector-length ,e)
     (emit-simple op e 'a0)
     (emit op "addi a0, a0, ~a" (- VEC-TAG))
     (emit op "ld a0, (a0)"))
    ((make-vector ,sz ,obj)
     (store-to-label op AP-REG 'free_ptr)
     (emit-foreign-call op 's_make_vector (list sz obj) si env)
     (load-from-label op AP-REG 'free_ptr))
    ((vector-ref ,v ,i)
     (emit-simple op i 'a1)
     (emit-simple op v 'a0)
     (emit op "add a0, a0, a1")
     (emit op "addi a0, a0, ~a" (- WORDSIZE VEC-TAG))
     (emit op "ld a0, (a0)"))
    ((vector-set! ,v ,i ,e)
     (emit-simple op v 'a0)
     (emit-simple op i 'a1)
     (emit-simple op e 'a2)
     (emit op "add a0, a0, a1")
     (emit op "addi a0, a0, ~a" (- WORDSIZE VEC-TAG))
     (emit op "sd a2, (a0)")
     (emit op "mv a0, x0"))
    ((procedure? ,e)
     (emit-simple op e 'a0)
     (emit op "andi a0, a0, ~a" PTR-MASK)
     (emit-eax=? op CLOS-TAG))
    ((symbol? ,e)
     (emit-simple op e 'a0)
     (emit op "andi a0, a0, ~a" PTR-MASK)
     (emit-eax=? op SYM-TAG))
    ((%string->symbol ,e)
     (emit-simple op e 'a0)
     (emit op "addi a0, a0, ~a" (- SYM-TAG STR-TAG)))
    ((%symbol->string ,e)
     (emit-simple op e 'a0)
     (emit op "addi a0, a0, ~a" (- STR-TAG SYM-TAG)))
    (,() (error "emit-prim" "unmatch" e))))

(define (emit-walk-stack op e si env)
  ;;; e is atomic expression
  ;;; NOTE:
  ;;; The procedure assume esp is the frame pointer
  ;;; And top stack pointer implied by the si parameter
  ;;; gc_flip(word_t fx_size, word_t *esp, word_t *ebp)
  (define (emit-call-gc-flip)
     (store-to-label op AP-REG 'free_ptr)
     (emit op "mv s3, sp")
     (emit op "mv s4, ra")
     (emit op "addi a1, sp, ~a" (- (- (abs si) WORDSIZE)))
     (emit op "mv a2, sp")
     (emit op "addi sp, sp, -~a" (- (abs si) WORDSIZE))
     (emit op "andi sp, sp, -16")
     (emit op "call gc_flip")
     (emit op "mv sp, s3")
     (emit op "mv ra, s4")
     (load-from-label op AP-REG 'free_ptr)
     ;;; NOTE: Restore back the closure pointer after GC
     (emit op "ld ~a, ~a(sp)" CLOS-REG (- WORDSIZE)))
  (cond
    ((not (integer? si))
     (error "emit-walk-stack" "unknown" si))
    ((eq? e -1)
     (emit-simple op e 'a0)
     (emit-call-gc-flip))
    (else
     (let ((cont (generate-label "cont"))
           (altern (generate-label "altern")))
        (emit-simple op e 'a0)
        ; max(sz,k) == sz < k ? k : sz
        ; sz < k ~> %rax < 
        (emit op "li t0, ~a" (immediate-rep GC-CTX-MIN-SIZE))
        (emit op "bge a0, t0, ~a" altern)
        (emit op "mv a0, t0")
        (emit op "~a: " altern)
        ; sz < fromspace_end - free_ptr
        (load-from-label op 't0 'fromspace_end)
        (emit op "sub t0, t0, ~a" AP-REG)
        (emit op "slli t0, t0, ~a" FIXNUM-SHIFT)
        (emit op "blt a0, t0, ~a" cont)
        (emit-call-gc-flip)
        (emit op "~a: " cont)))))

(define (emit-tail-call op maybe-decl fn args si env)
  (let* ((argc (length (cons fn args)))
         (calc-offset (lambda (i) (- si (* WORDSIZE i)))))
    (for-each
      (lambda (offset arg)
        (emit-simple op arg 'a0)
        (emit op "sd a0, ~a(sp)" offset))
      (map calc-offset (iota argc))
      (cons fn args))
    ;;; copying the memory
    (for-each
      (lambda (i)
        (emit op "ld a0, ~a(sp)" (calc-offset i))
        (emit op "sd a0, ~a(sp)" (* (- WORDSIZE) (+ i 1))))
      (iota argc))
    (emit op "li t0, ~a" argc)
    (match maybe-decl
      ((label ,lbl)
       (emit op "addi sp, sp, ~a" WORDSIZE)
       (emit op "j ~a" lbl))
      (#f
       (emit op "ld a0, ~a(sp)" (- WORDSIZE))
       (emit op "addi a0, a0, ~a" (- CLOS-TAG))
       (emit op "ld a0, (a0)")
       (emit op "addi sp, sp, ~a" WORDSIZE)
       (emit op "jalr x0, a0, 0"))
      (,() (error "emit-tail-call" "unmatch" maybe-decl)))))

(define (emit-call op maybe-decl fn args si env)
  (let* ((argc (length (cons fn args)))
         (start-si (- si (* 2 WORDSIZE)))
         (calc-offset (lambda (i) (- start-si (* WORDSIZE i)))))
    (emit op "sd x0, ~a(sp)" si)
    ;;; this store the frame pointer
    (emit op "sd sp, ~a(sp)" (- si WORDSIZE))
    (for-each
      (lambda (offset arg)
        (emit-simple op arg 'a0)
        (emit op "sd a0, ~a(sp)" offset))
      (map calc-offset (iota argc))
      (cons fn args))
    (emit op "li t0, ~a" argc)
    (match maybe-decl
      ((label ,lbl)
       (emit op "addi sp, sp, -~a" (- (abs si) WORDSIZE))
       (psuedo-push op 'ra)
       (emit op "jal ra, ~a" lbl)
       (psuedo-pop op 'ra))
      (#f
       (emit op "ld a0, ~a(sp)" start-si)
       (emit op "addi a0, a0, ~a" (- CLOS-TAG))
       (emit op "ld a0, (a0)")
       (emit op "addi sp, sp, -~a" (- (abs si) WORDSIZE))
       (psuedo-push op 'ra)
       (emit op "jalr ra, a0, 0")
       (psuedo-pop op 'ra))
      (,() (error "emit-call" "unmatch" maybe-decl)))
    (emit op "addi sp, sp, ~a" (- (abs si) WORDSIZE))
    (emit op "ld ~a, ~a(sp)" CLOS-REG (- WORDSIZE))))

(define (emit-foreign-call op fn args si env)
  (let* ((argc (length args))
         (end-si si))
    (let loop ((args args) (regs REGISTERS))
      (if (pair? args)
          (begin
            (emit-simple op (car args) (car regs))
            (loop (cdr args) (cdr regs)))))
    (emit op "mv s3, sp")
    (emit op "mv s4, ra")
    (emit op "addi sp, sp, -~a" (abs end-si))
    (emit op "and sp, sp, -16")
    (emit op "call ~a" fn)
    (emit op "mv ra, s4")
    (emit op "mv sp, s3")))

(define (emit-tail-apply op fn es si env)
  (emit-simple op fn 'a1)
  (emit-simple op es 'a0)
  (emit op "sd a0, ~a(sp)" (- (* 2 WORDSIZE)))
  (emit op "sd a1, ~a(sp)" (- WORDSIZE))
  (emit op "addi sp, sp, ~a" WORDSIZE)
  (emit op "j L_apply"))

(define (emit-apply op fn es si env)
  (emit op "sd sp, ~a(sp)" (- si WORDSIZE))
  (emit-simple op fn 'a0)
  (emit op "sd a0, ~a(sp)" (- si (* 2 WORDSIZE)))
  (emit-simple op es 'a0)
  (emit op "sd a0, ~a(sp)" (- si (* 3 WORDSIZE)))
  (emit op "addi sp, sp, -~a" (- (abs si) WORDSIZE))
  (psuedo-push op 'ra)
  (emit op "call L_apply")
  (psuedo-pop op 'ra)
  (emit op "addi sp, sp, ~a" (- (abs si) WORDSIZE))
  (emit op "ld ~a, ~a(sp)" CLOS-REG (- WORDSIZE)))

(define (emit-L-apply op)
  (let ((loop (generate-label "unstack"))
        (end (generate-label "call")))
    (emit op ".p2align 3")
    (emit op "L_apply: ")
    ;;; (apply fn es)
    ;;; a0 : es
    ;;; a1 : moving stack pointer
    ;;; a2 : argc
    (emit op "sd a0, ~a(sp)" (- (* 3 WORDSIZE)))
    (emit op "addi a1, sp, ~a" (- (* 3 WORDSIZE)))
    (emit op "li a2, 1")
    (emit op "li t0, ~a" NIL-TAG)
    (emit op "~a: " loop)
    (emit op "beq a0, t0, ~a" end)
    (emit op "addi a0, a0, ~a" (- PAIR-TAG))
    (emit op "ld t1, (a0)")
    (emit op "sd t1, (a1)")
    (emit op "ld a0, ~a(a0)" WORDSIZE)
    (emit op "addi a1, a1, ~a" (- WORDSIZE))
    (emit op "addi a2, a2, 1")
    (emit op "j ~a" loop)
    (emit op "~a: " end)
    (emit op "mv t0, a2")
    (emit op "ld a0, ~a(sp)" (- (* 2 WORDSIZE)))
    (emit op "addi a0, a0, ~a" (- CLOS-TAG))
    (emit op "ld a0, (a0)")
    (emit op "jalr x0, a0, 0")))

(define (emit-construct-vararg op argc si)
  #;(
      [z 1]
      ()  0
      (1) 1

      [(x y . z) 3]
      (0)           1   err
      (0 1)         2   (0 1 ())
      (0 1 2)       3   (0 1 (2))
      (0 1 2 3)     4   (0 1 (2 3))
      (0 1 2 3 4)   5   (0 1 (2 3 4))
      
      example
      inp         cons    argc  sz
      (0 1 2 3 4) ()      5     3
      (0 1 2 3)   (4)     4     3
      (0 1 2)     (3 4)   3     3
      (0 1)       (2 3 4) 2     3
  )
  (emit op "la t1, free_ptr")
  (emit op "sd ~a, (t1)" AP-REG)
  (emit op "mv s3, sp")
  (emit op "mv s4, ra")
  (emit op "slli t0, t0, ~a" FIXNUM-SHIFT)
  (emit op "sub sp, sp, t0")

  (emit op "li a0, ~a" argc)
  (emit op "mv a1, t0")
  (emit op "mv a2, sp")
  (emit op "mv a3, s3")
  (emit op "andi sp, sp, -16")
  (emit op "call construct_vararg")
  (emit op "mv ra, s4")
  (emit op "mv sp, s3")
  (emit op "sd a0, ~a(sp)" (* (- WORDSIZE) argc))
  (load-from-label op AP-REG 'free_ptr))

(define (emit-procedure op fn params variadic? fvs body)
  (let* ((argc (length params))
         (env (make-env))
         (si (* (- WORDSIZE) (+ argc 1))))
    (emit op ".p2align 3")
    (emit op ".globl ~a" fn)
    (emit op ".type ~a, @function" fn)
    (emit op "~a: " fn)
    (emit op "addi sp, sp, -~a" WORDSIZE)
    (if (not variadic?)
        (let ((end (generate-label 'conseq)))
          (emit op "li t1, ~a" argc)
          (emit op "beq t0, t1, ~a" end)
          (emit-foreign-call op 's_proc_arg_err '() si env)
          (emit op "~a: " end))
        (emit-construct-vararg op argc si))
    ;;; NOTE: first argument is always the closure
    (emit op "ld ~a, ~a(sp)" CLOS-REG (- WORDSIZE))
    (match body
      (((alloca ,i) . ,body)
       (guard (and (integer? i) (<= (sub1 argc) i)))
       (for-each
          (lambda (i)
            (emit op "sd x0, ~a(sp)"
                     (* (- WORDSIZE) (+ i 2))))
          (filter (lambda (i) (<= argc i)) (iota i)))
       (emit-seq op body (* (- WORDSIZE) (+ i 2)) env))
      (,() (error "emit-procedure" "unknown body" body)))
    (emit op "addi sp, sp, ~a" WORDSIZE)
    (emit op "ret")))

(define (emit-variadic-procedure op fn fvs clauses)
  (let* ((env (make-env)))
    (emit op ".p2align 3")
    (emit op ".globl ~a" fn)
    (emit op ".type ~a, @function" fn)
    (emit op "~a: " fn)
    (emit op "ld ~a, ~a(sp)" CLOS-REG (- (* WORDSIZE 2)))
    (for-each
      (lambda (clause)
        (match clause
          ((closure ,fn ,fvs ,variadic? ,argc)
           (let ((next (generate-label "case_lambda_altern")))
            (cond
              (variadic?
               (emit op "li a0, ~a" (sub1 argc))
               (emit op "blt t0, a0, ~a" next))
              (else
               (emit op "li a0, ~a" argc)
               (emit op "bne t0, a0, ~a" next)))
            (emit op "mv s3, t0")
            (emit-closure op fn fvs #f env)
            (emit op "sd a0, ~a(sp)" (- (* WORDSIZE 2)))
            (emit op "mv t0, s3")
            (emit op "j ~a" fn)
            (emit op "~a: " next)))
          (,() (error "emit-variadic-procedure" "unknown clause" clause))))
      clauses)
    (emit-foreign-call op 's_proc_arg_err '() (- (* 2 WORDSIZE)) env)))

(define (emit-closure op fn fvs si env)
  (define fvs-count (length fvs))
  (emit op "mv a0, ~a" AP-REG)
  (emit op "addi ~a, ~a, ~a"
           AP-REG AP-REG (align-to-multiple 8 (* WORDSIZE (+ 2 fvs-count))))
  (emit op "la t0, ~a" fn)
  (emit op "sd t0, (a0)")
  (emit op "li t0, ~a" (immediate-rep fvs-count))
  (emit op "sd t0, ~a(a0)" WORDSIZE)
  (for-each
    (lambda (fv i)
      (emit-simple op fv 'a1)
      (emit op "sd a1, ~a(a0)" (* WORDSIZE (+ 2 i))))
    fvs
    (iota fvs-count))
  (emit op "ori a0, a0, ~a" CLOS-TAG))

(define (emit-seq op es si env)
  (for-each
    (lambda (e) (emit-expr op e si env))
    es))

(define (emit-expr op e si env)
  (match e
    (,()
     (guard (immediate? e))
     (emit op "li a0, ~a" (immediate-rep e)))
    (,()
     (guard (string? e))
     (emit-str-lit op e si))
    ;;; NOTE:
    ;;; Suppose wordsize=4
    ;;; (%rsp) points to frame pointer, -4(%rsp) points to closure pointer
    ;;; therefore, first local (i = 0) starts at (-4 * (+ 0 2))(%rsp) = -8(%rsp)
    ((local-set! ,i ,e)
     (guard (integer? i))
     (emit-expr op e si env)
     (emit op "sd a0, ~a(sp)" (* (- WORDSIZE) (+ i 2))))
    ((local-ref ,i)
     (guard (integer? i))
     (emit op "ld a0, ~a(sp)" (* (- WORDSIZE) (+ i 2))))
    ((quote ())
     (emit op "li a0, ~a" (immediate-rep '())))
    ((collect)
     (emit-walk-stack op -1 si env))
    ((collect ,sz)
     (emit-walk-stack op sz si env))
    ((global ,lbl)
     (load-from-label op 'a0 lbl))
    ((label ,lbl)
     (load-from-label op 'a0 lbl))
    ((closure-ref ,() ,i)
     (guard (integer? i))
     (emit op "mv a0, ~a" CLOS-REG)
     (emit op "add a0, a0, ~a" (- (* WORDSIZE (+ i 2)) CLOS-TAG))
     (emit op "ld a0, (a0)"))
    ((set-label! ,lbl ,e)
     (emit-expr op e si env)
     (store-to-label op 'a0 lbl))
    ((begin . ,es)
     (emit-seq op es si env))
    ((if ,pred ,conseq ,altern)
     (emit-if op pred conseq altern si env))
    ((closure ,fn ,fvs)
     (emit-closure op fn fvs si env))
    ((call ,tail? (prim apply) ,fn ,es)
     ((if tail? emit-tail-apply emit-apply) op fn es si env))
    ((call ,() (prim ,pr) . ,es)
     (emit-prim op (cons pr es) si env))
    ((call ,tail? ,maybe-decl ,fn . ,es)
     ((if tail? emit-tail-call emit-call) op maybe-decl fn es si env))
    ((foreign-call! ,fn . ,es)
     (store-to-label op AP-REG 'free_ptr)
     (emit-foreign-call op fn es si env)
     (load-from-label op AP-REG 'free_ptr))
    ((foreign-call ,fn . ,es)
     (emit-foreign-call op fn es si env))
    (,() (error "emit-expr" "unmatch" e))))

(define (psuedo-push op reg)
  (emit op "addi sp, sp, -8")
  (emit op "sd ~a, 0(sp)" reg))

(define (psuedo-pop op dest-reg)
  (emit op "ld ~a, 0(sp)" dest-reg)
  (emit op "addi sp, sp, 8"))

(define (emit-code op entry-name prog)
  (match prog
    ((program (labels . ,labels)
              (data . ,data)
              (unbounds . ,unbounds)
              ((alloca ,i) . ,body))
     ;;; NOTE:
     ;;; referenced operand position primitives are not externed here
     ;;; but dont know what are the risk
     (emit op ".globl ~a" entry-name)
     (emit op ".extern L_apply")
     (for-each (lambda (g) (emit op ".extern ~a" g)) (set-union data unbounds))
     (emit op ".section .text")
     (for-each
       (lambda (label)
         (match label
           ((,name (code ,params ,variadic? ,fvs ,e))
            (emit-procedure op name params variadic? fvs e))
           ((,name (case-code ,fvs . ,clauses))
            (emit-variadic-procedure op name fvs clauses))
           (,() (error "emit-code" "unmatch" label))))
       labels)
     (emit op "~a:" entry-name)
     (psuedo-push op "fp")
     (emit op "mv fp, sp")
     (for-each
       (lambda (i) (emit op "sd x0, ~a(sp)" (* (- WORDSIZE) (+ i 1))))
       (iota (+ i 1)))
     (emit-seq op body (* (- WORDSIZE) (+ i 2)) (make-env))
     (emit op "li a0, 0")
     (psuedo-pop op "fp")
     (emit op "ret"))
    (,() (error "emit-code" "unmatch" prog))))

(define (program->data prog)
  (match prog
    ((program (labels . ,()) (data . ,data) (unbounds . ,()) ,()) data)
    (,() (error "program->data" "unmatch" prog))))

(define (emit-obj input-path output-path k)
  (define tmp-filename (mk-tmpname (path-fileroot input-path) "s"))
  (let* ((prog (preprocess (cons 'begin (read-sexps-from-path input-path))))
         (entry-name (format "~a.main" (string->id-string (path-fileroot input-path))))
         (data (program->data prog))
         (op (open-output-file tmp-filename)))
    (emit-code op entry-name prog)
    (close-output-port op)
    (system* "~a ~a -c ~a -o ~a"
             CC CC-ARGS
             tmp-filename output-path)
    (system* "rm -f ~a" tmp-filename)
    (k entry-name data)))

(define (read-meta obj-file)
  (let* ((filename (mk-tmpname "read-meta" "txt"))
          (_ (system* "~a --dump-section .main_entry=~a ~a"
                      OBJCOPY
                      filename obj-file))
          (inp (open-input-file filename))
          (meta (read inp)))
    (close-port inp)
    (system* "rm -f ~a" filename)
    meta))

(define (map3-k f xs k)
  (let recur ((xs xs) (k k))
    (if (not (pair? xs))
        (k '() '() '())
        (f (car xs)
          (lambda (x y z)
            (recur (cdr xs)
              (lambda (xs ys zs)
                (k (cons x xs) (cons y ys) (cons z zs)))))))))

(define (emit-objs input-paths k)
  (map3-k
    (lambda (i k)
      (if (equal? (path-extension i) "o")
          (let ((out (mk-tmpname i "o")))
            (system* "cp ~a ~a" i out)
            (k out (read-meta out) (lambda () (system* "rm -f ~a" out))))
          (let ((out (mk-tmpname i "o")))
            (emit-obj i out
              (lambda (entry-name data) (k out (list (list entry-name) data) (lambda () (system* "rm -f ~a" out))))))))
    input-paths
    k))

(define (combine-objs output-path objs metas)
  (define entries (apply append (map car metas)))
  (define globals (apply set-union (map cadr metas)))
  (system* "~a ~a -r -o ~a ~a"
           CC CC-ARGS
           output-path
           (apply string-append
                  (map (lambda (s) (string-append " \"" s "\" ")) objs)))
  (system* "~a --remove-section=.main_entry --add-section .main_entry=<(echo ~s) ~a"
           OBJCOPY
           (format "~s" (list entries globals))
           output-path))

(define (emit-main output-path objs metas)
  (define (make-prim-call pr . es)
    `(call #f (prim ,pr) . ,es))
  (define (make-box-init e)
    (make-prim-call 'cons e '(quote ())))
  (define entries (apply append (map car metas)))
  (define globals (apply set-union (map cadr metas)))
  (define tmp-filename (mk-tmpname (string-append (path-fileroot output-path) "-exec") "s"))
  (let* ((op (open-output-file tmp-filename)))
    (emit op ".globl main")
    (emit op ".globl L_apply")
    (for-each (lambda (g) (emit op ".globl ~a" g)) globals)

    (emit op ".section .data")
    (emit op ".globl global_table")
    (emit op "global_table:")
    (for-each
      (lambda (g) (emit op ".~abyte ~a" WORDSIZE g))
      globals)
    (emit op ".~abyte 0" WORDSIZE)
    (for-each
      (lambda (g)
      (match g
        (,()
         (guard (symbol? g))
         (emit op ".p2align 3")
         (emit op "~a: .~abyte 0" g WORDSIZE))
        (,() (error "linking-to-exe" "unmatch" g))))
      globals)
    (emit op ".section .text")
    (emit-L-apply op)
    (emit op "main:")
    (store-to-label op "sp" "BOT_EBP")
    (emit op "mv fp, sp")
    (store-to-label op 'a1 'ARGV)
    (store-to-label op 'a0 'ARGC)
    (psuedo-push op 'ra)
    (emit op "call init_heap")
    (psuedo-pop op 'ra)
    (load-from-label op AP-REG "free_ptr")
    (emit op "# globals")
    (for-each
      (lambda (g)
        (emit-expr op `(set-label! ,g ,(make-box-init 0)) (- WORDSIZE) #f))
      globals)
    (emit op "# end of globals")
    (for-each
      (lambda (entry)
        (psuedo-push op 'ra)
        (emit op "call ~a" entry)
        (psuedo-pop op 'ra))
      entries)
    (emit op "li a0, 0")
    (emit op "ret")
    (close-output-port op))
  (system* "~a ~a ~a ~a -r -o ~a"
           CC CC-ARGS
           tmp-filename
           (apply string-append
                  (map (lambda (s) (string-append " \"" s "\" ")) objs))
            output-path)
  (system* "rm -f ~a" tmp-filename))

(match (cdr (command-line))
  (("-o" ,output-path . ,input-paths)
   (guard (equal? (path-extension output-path) "out"))
   (emit-objs input-paths
    (lambda (objs metas frees)
      (let ((tmp-filename (mk-tmpname (path-fileroot output-path) "o")))
        (emit-main tmp-filename objs metas)
        (system* "~a ~a runtime.o ~a -o ~a"
                 CC CC-ARGS
                 tmp-filename output-path)
        (system* "rm -f ~a" tmp-filename))
      (map (lambda (f) (f)) frees))))
  (("-o" ,output-path . ,input-paths)
   (guard (equal? (path-extension output-path) "o"))
   (emit-objs input-paths
    (lambda (objs metas frees)
      (combine-objs output-path objs metas)
      (map (lambda (f) (f)) frees))))
  (("--emit-main" ,output-path . ,input-paths)
   (emit-objs input-paths
    (lambda (objs metas frees)
      (emit-main output-path objs metas)
      (map (lambda (f) (f)) frees))))
  (("--bin" ,output-path ,runtime ,main)
   (system* "~a ~a ~a ~a -o ~a" CC CC-ARGS runtime main output-path))
  (("--make-prim-lib" ,output-path)
   (write-primitive-lib output-path))
  ((,input-path . ,input-paths)
   (emit-objs (cons input-path input-paths)
    (lambda (objs metas frees)
      (let* ((tmpname (mk-tmpname "tmp" ""))
             (final (string-append tmpname ".o"))
             (out (string-append tmpname ".out")))
        (emit-main final objs metas)
        (system* "~a ~a runtime.o ~a -o ~a"
                 CC CC-ARGS
                 final out)
        (system* out)
        (system* "rm -f ~a ~a" final out))
      (map (lambda (f) (f)) frees))))
  (,cmd-ln (error (car (command-line)) "unmatch" cmd-ln)))
)