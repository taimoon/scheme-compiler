(import
  (only (match) match)
  (only (set) make-set list->set set-union set-diff set-symmetric-diff)
  (only (desugar) make-begin)
  (only (utils)
    writeln
    lsort partition zip-k
    read-sexps-from-path apply-env extend-env))

(define (flatten-live-sets live-sets)
  (define (f live-set live-sets)
    (match live-set
       ((if ,conseq ,altern)
        (append (flatten-live-sets conseq)
                (flatten-live-sets altern)
                live-sets))
       (,live-set (cons live-set live-sets))))
  (fold-right f '() live-sets))

(define (map-live-sets f live-sets)
  (define (f* live-set)
    (match live-set
       ((if ,conseq ,altern)
        `(if ,(map-live-sets f conseq) ,(map-live-sets f altern)))
       (,live-set (f live-set))))
  (map f* live-sets))

(define (strip-emtpy-live-sets live-sets)
  (if (not (pair? live-sets))
      '()
      (match (car live-sets)
        ((if ,conseq ,altern)
         (let ((conseq (strip-emtpy-live-sets conseq))
               (altern (strip-emtpy-live-sets altern)))
          (if (not (or (pair? conseq) (pair? altern)))
              (strip-emtpy-live-sets (cdr live-sets))
              (cons `(if ,conseq ,altern)
                    (strip-emtpy-live-sets (cdr live-sets))))))
        (() (strip-emtpy-live-sets (cdr live-sets)))
        (,live-set
         (cons live-set (strip-emtpy-live-sets (cdr live-sets)))))))

;;; uncover-live-sets
(define (simple? e)
  (or (integer? e) (boolean? e) (char? e) (symbol? e)
      (match e
        ((,form ,())
         (or (eq? form 'label)
             (eq? form 'global)
             (eq? form 'quote)))
        (,() #f))))

(define (closure-ref? e)
  (match e
    ((closure-ref ,clos ,i)
     (if (not (and (symbol? clos) (integer? i)))
         (error "uncover-live-exp" "bad closure-ref" e)
         #t))
    (,() #f)))

(define (uncover-live-exp e)
  (match e
    (,()
     (guard (symbol? e))
     (make-set e))
    (,()
     (guard (or (simple? e) (string? e)))
     (make-set))
    ((closure ,lbl ,fvs)
     (if (not (andmap simple? fvs))
         (error "uncover-live-exp" "clousre:expect-simple" e)
         (list->set (filter symbol? fvs))))
    ((closure-ref ,clos ,i)
     (if (not (and (symbol? clos) (integer? i)))
         (error "uncover-live-exp" "bad closure-ref" e)
         (make-set)))
    ((set-label! ,x ,e)
     (cond
      ((not (simple? e))
       (error "uncover-live-exp" "set-label!expect-simple" e))
      ((symbol? e)
       (make-set e))
      (else (make-set))))
    ((call ,tail? ,maybe-decl . ,vs)
     (guard (andmap simple? vs))
     (list->set (filter symbol? vs)))
    ((,fcall ,fn . ,vs)
     (guard (and (memq fcall '(foreign-call foreign-call!)) (andmap simple? vs)))
     (list->set (filter symbol? vs)))
    (,() (error "uncover-live-exp" "unmatch" e))))

(define (uncover-live e)
  (match e
    ((let ((_ (collect ,sz))) ,e2)
     (if (not (simple? sz))
         (error "uncover-live" "collect:expect-simple-size" sz)
         (let ((live-sets (uncover-live e2)))
            (cons (set-union (uncover-live-exp sz) (car live-sets)) live-sets))))
    ((let ((_ (collect))) ,e2)
     (uncover-live e2))
    ((let ((,x (if ,pred ,conseq ,altern))) ,body)
     (if (not (simple? pred))
         (error "uncover-live" "if:expect-simple" pred)
         (let ((pred (uncover-live-exp pred))
               (conseq (uncover-live conseq))
               (altern (uncover-live altern))
               (live-sets (uncover-live body)))
          `(,(set-union pred (car conseq) (car altern)
                        (set-symmetric-diff (car live-sets) (if (eq? x '_) (make-set) (make-set x))))
            (if ,conseq ,altern)
            ,@live-sets))))
    ((let ((_ ,e1)) ,e2)
     (let ((live-sets (uncover-live e2)))
      (cons (set-union (uncover-live-exp e1) (car live-sets)) live-sets)))
    ((let ((,x ,e1)) ,e2)
     (let ((live-sets (uncover-live e2))
           (lives (uncover-live-exp e1)))
      (cons (set-union lives (set-symmetric-diff (car live-sets) (make-set x))) live-sets)))
    ((let ,bs ,e)
     (if (not (andmap simple? (map car bs)))
         (error "uncover-live" "bad-let-inits" bs)
         (let* ((live-sets (uncover-live e)))
          (cons
            (set-symmetric-diff
              (list->set (map car bs))
              (set-union (car live-sets) (list->set (filter symbol? (map cadr bs)))))
            live-sets))))
    ((if ,pred ,conseq ,altern)
     (if (not (simple? pred))
         (error "uncover-live" "tail-if:expect-simple" pred)
         (let ((pred (uncover-live-exp pred))
               (conseq (uncover-live conseq))
               (altern (uncover-live altern)))
          `(,(set-union pred (car conseq) (car altern))
            (if ,conseq ,altern)))))
    (,()
     (list (uncover-live-exp e)))
    (,() (error "uncover-live" "unmatch" e))))

(define (mappend-live-set append live-set live-sets)
  (map-live-sets (lambda (live-set*) (append live-set live-set*)) live-sets))

(define (fix-if-live-sets live-sets)
  (define (fix-if-live-set live-set)
    (match live-set
      ((if ,conseq ,altern)
       `(if ,(fix-if-live-sets conseq) ,(fix-if-live-sets altern)))
      (,live-set live-set)))
  (let fix-if-live-sets ((live-sets live-sets))
    (cond
      ((not (pair? live-sets))
       '())
      ((not (pair? (cdr live-sets)))
       (list (fix-if-live-set (car live-sets))))
      (else
        (let ((live-set (fix-if-live-set (car live-sets)))
              (live-sets (fix-if-live-sets (cdr live-sets))))
          (match live-set
            ((if ,conseq ,altern)
             `((if ,(mappend-live-set set-union (car live-sets) conseq)
                   ,(mappend-live-set set-union (car live-sets) altern))
               ,@live-sets))
            (,() (cons live-set live-sets))))))))

(define (uncover-live* e)
  (define (pipe x . fs)
    (fold-left (lambda (x f) (f x)) x fs))
  (pipe
    e
    uncover-live
    strip-emtpy-live-sets
    fix-if-live-sets))

(define (max-loc-req live-sets)
  (apply max (cons 0 (map length (flatten-live-sets live-sets)))))

(define (append-sort sort-1 sort-2)
  (cond
    ((not (pair? sort-1)) sort-2)
    ((not (pair? sort-2)) sort-1)
    ((< (car sort-1) (car sort-2))
     (cons (car sort-1) (append-sort (cdr sort-1) sort-2)))
    (else
     (cons (car sort-2) (append-sort sort-1 (cdr sort-2))))))

;;; NOTE: append is for debugging, and you need flatten the var-locs afterwards if you use it
(define linear-alloc (let ((append-var-locs set-union))
  (define (assign-loc live-set live-sets var-locs locs)
    (partition (lambda (var-loc) (member (car var-loc) live-set)) var-locs
      (lambda (lives deads)
        (zip-k (set-diff live-set (map car lives))
               ;;; NOTE: variables are not dead in ordered
               (append-sort (lsort (map cadr deads)) locs)
               (lambda (var-locs locs)
                (let ((var-locs (append lives var-locs)))
                 (append-var-locs var-locs (%linear-alloc live-sets var-locs locs))))))))
  (define (%linear-alloc live-sets var-locs locs)
    (if (not (pair? live-sets))
        '()
        (match (car live-sets)
          ((if ,conseq ,altern)
           (append-var-locs
            (%linear-alloc conseq var-locs locs)
            (%linear-alloc altern var-locs locs)
            (%linear-alloc (cdr live-sets) var-locs locs)))
          (,live-set
           (assign-loc live-set (cdr live-sets) var-locs locs)))))
  (case-lambda
    ((live-sets) (%linear-alloc live-sets '() (iota (max-loc-req live-sets))))
    ((live-sets var-locs locs) (%linear-alloc live-sets var-locs locs)))))

(define (alloc-local-loc code k)
  (define (flatten-var-locs var-locs)
    ;;; for debugging
    #;(apply set-union var-locs)
    var-locs)
  (match code
    ((code (,clos . ,params) ,variadic? ,() ,e)
     (let* ((live-sets (cons params (uncover-live* e)))
            (n (max-loc-req live-sets))
            (locs (iota n)))
      (zip-k params locs
        (lambda (var-locs locs)
          (k n (flatten-var-locs (linear-alloc live-sets var-locs locs)))))))
    ((case-code . ,())
     (k 0 '()))
    (,e 
     (let* ((live-sets (uncover-live* e))
            (n (max-loc-req live-sets))
            (locs (iota n))
            (var-locs (flatten-var-locs (linear-alloc live-sets '() locs))))
        (k n var-locs)))))

(define (assign-home-each es env)
  (map (lambda (e) (assign-home e env)) es))

(define (assign-home e env)
  (match e
    (,()
     (guard (or (simple? e) (string? e)))
     (if (symbol? e)
         `(local-ref ,(apply-env e env))
         e))
    ((prim ,pr)
     e)
    ((let ((_ ,e1)) ,e2)
     `(let ((_ ,(assign-home e1 env)))
        ,(assign-home e2 env)))
    ((let ((,x ,e1)) ,e2)
      `(let ((_ (local-set! ,(apply-env x env) ,(assign-home e1 env))))
        ,(assign-home e2 env)))
    ((set-label! ,x ,e)
     `(set-label! ,x ,(assign-home e env)))
    ((closure ,fn ,fvs)
     `(closure ,fn ,(assign-home-each fvs env)))
    ((closure-ref . ,())
     e)
    ((collect)
     e)
    ((collect ,e)
     `(collect ,(assign-home e env)))
    ((if . ,es)
     `(if . ,(assign-home-each es env)))
    ((call . ,es)
     `(call . ,(assign-home-each es env)))
    ((,fcall ,fn . ,es)
     (guard (memq fcall '(foreign-call foreign-call!)))
     `(,fcall ,fn . ,(assign-home-each es env)))
    (,() (error "assign-home" "unmatch" e))))

(define (assign-home-program prog)
  (define (flatten-var-locs var-locs) (apply set-union var-locs))
  (define (assign-home-code code)
    (match code
      ((code ,params ,variadic? ,fvs ,e)
       (alloc-local-loc code
        (lambda (n var-locs)
          `(code ,params ,variadic? ,fvs
            (let ((_ (alloca ,n)))
            ,(assign-home e var-locs))))))
      ((case-code . ,())
       code)
      (,e
       (alloc-local-loc e
        (lambda (n var-locs)
          `(let ((_ (alloca ,n)))
            ,(assign-home e var-locs)))))))
  (match prog
    ((program (labels . ,codes) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program
        (labels . ,(map (lambda (c) (list (car c) (assign-home-code (cadr c)))) codes))
        (data . ,data)
        (unbounds . ,unbounds)
        ,(assign-home-code e)))
    (,() (error "assign-home-program" "unmatch" prog))))

(define (single-val! v)
  (if (and (pair? v) (not (pair? (cdr v))))
      (car v)
      (error "lower-let" "local-set!-expect-single-value" v)))

(define (lower-let e)
  (match e
    ((code ,params ,variadic? ,fvs ,e)
     `(code ,params ,variadic? ,fvs ,(lower-let e)))
    ((case-code . ,())
     e)
    (,()
     (guard (or (string? e) (simple? e)))
     (list e))
    ((let ((_ ,e1)) ,e2)
     (match e1
      (,()
       (guard (simple? e1))
       `(,e1 ,@(lower-let e2)))
      ((alloca . ,())
       `(,e1 ,@(lower-let e2)))
      ((collect . ,())
       `(,e1 ,@(lower-let e2)))
      ((,call . ,vs)
       (guard (memq call '(call foreign-call foreign-call!)))
       `(,e1 ,@(lower-let e2)))
      ((local-set! ,i ,e1)
       `((local-set! ,i ,(single-val! (lower-let e1))) ,@(lower-let e2)))
      ((set-label! ,x ,e1)
       `((set-label! ,x ,(single-val! (lower-let e1))) ,@(lower-let e2)))
      ((if ,pred ,conseq ,altern)
       `((if ,pred ,(make-begin (lower-let conseq)) ,(make-begin (lower-let altern))) ,@(lower-let e2)))
      (,() (error "lower-let" "unknown init" e1))))
    ((if ,pred ,conseq ,altern)
     (list `(if ,pred ,(make-begin (lower-let conseq)) ,(make-begin (lower-let altern)))))
    ((,form . ,())
     (guard (memq form '(closure closure-ref call local-ref apply foreign-call foreign-call!)))
     (list e))
    (,() (error "lower-let" "unmatch" e))))

(define (lower-let-program prog)
  (match prog
    ((program (labels . ,codes) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program
        (labels . ,(map (lambda (c) (list (car c) (lower-let (cadr c)))) codes))
        (data . ,data)
        (unbounds . ,unbounds)
        ,(lower-let e)))
    (,() (error "lower-let-program" "unmatch" prog))))
