(import
  (only (desugar) write-primitive-lib)
  (only (front) preprocess)
  (only (match) match)
  (only (set) make-set set-union set-diff)
  (only (utils)
    make-env extend-env maybe-apply-env apply-env
    read-sexps-from-path align-to-multiple
    random-string symbol->id-symbol string->id-string generate-label
    system*
    path-fileroot path-filename))

(let ()
(define REGISTERS '(%rdi %rsi %rdx %rcx %r8 %r9))
(define FIXNUM-MASK   #b00000111)
(define FIXNUM-TAG    #b00000000)
(define FIXNUM-SHIFT  3)
(define IMM-SHIFT     8)
(define IMM-MASK      #b11111111)
(define IMM-TAG       #b00000111)
(define EOF-TAG       #b00000111)
(define CHAR-TAG      #b00001111)
(define BOOL-TAG      #b00011111)
(define NIL-TAG       #b00111111)
(define FALSE-IMM     BOOL-TAG)
(define TRUE-IMM      (bitwise-ior (ash 1 IMM-SHIFT) BOOL-TAG))
(define PTR-MASK      #b00000111)
(define PAIR-TAG      #b00000001)
(define VEC-TAG       #b00000010)
(define STR-TAG       #b00000011)
(define SYM-TAG       #b00000101)
(define CLOS-TAG      #b00000110)
(define GC-CTX-MIN-SIZE 64)
(define CC "gcc")
(define CC-ARGS "-g -fno-omit-frame-pointer -m64 -march=x86-64")

(define WORDSIZE 8)
(define CLOS-REG "%r12")
(define AP-REG "%r13")

;;; emit
(define (emit op . args)
  (apply format (cons op args))
  (newline op))

(define (immediate? v)
  (or (integer? v) (boolean? v) (char? v)))

(define (immediate-rep imm)
  (cond
    ((char? imm)
     (bitwise-ior CHAR-TAG
                  (ash (char->integer imm)
                       IMM-SHIFT)))
    ((boolean? imm)
     (if imm TRUE-IMM FALSE-IMM))
    ((integer? imm)
     (ash imm FIXNUM-SHIFT))
    ((null? imm)
     NIL-TAG)
    (else (error "immediate-rep" "unknown immediate" imm))))

(define (emit-eax=? op v)
  (emit op "cmp $~a, %rax" v)
  (emit op "sete %al")
  (emit op "sal $~a, %rax" IMM-MASK)
  (emit op "or $~a, %rax" BOOL-TAG))

(define suffix-cmp
  '((< setl jl)
    (<= setle jle)
    (= sete je)
    (eq? sete je)
    (> setg jg)
    (>= setge jge)))

(define (emit-cmp op cmp e1 e2 si env)
  (emit-simple op e1 '%rcx)
  (emit-simple op e2 '%rax)
  (emit op "cmp %rax, %rcx")
  (emit op "mov $0, %rax")
  (emit op "~a %al" (cadr (assq cmp suffix-cmp)))
  (emit op "sal $~a, %rax" IMM-SHIFT)
  (emit op "or $~a, %rax" BOOL-TAG))

(define (emit-if op pred conseq altern si env)
  (let ((end-label (generate-label "end"))
        (altern-label (generate-label "altern")))
    (emit-expr op pred si env)
    (emit op "cmp $~a, %rax" FALSE-IMM)
    (emit op "je ~a" altern-label)
    ;;; NOTE: for debugging purpose
    (emit op "~a :" (generate-label "conseq"))
    (emit-expr op conseq si env)
    (emit op "jmp ~a" end-label)
    (emit op "~a: " altern-label)
    (emit-expr op altern si env)
    (emit op "~a: " end-label)))

(define (emit-str-lit op s si)
  (emit op "mov ~a, %rax" AP-REG)
  (emit op "add $~a, ~a"
           (align-to-multiple 8 (+ WORDSIZE (+ 1 (string-length s))))
           AP-REG)
  (emit op "movq $~a, (%rax)" (immediate-rep (string-length s)))
  (for-each
    (lambda (i)
      (emit op "movb $~a, ~a(%rax)"
               (char->integer (string-ref s i))
               (+ WORDSIZE i)))
    (iota (string-length s)))
  (emit op "movb $0, ~a(%rax)" (+ WORDSIZE (string-length s)))
  (emit op "or $~a, %rax" STR-TAG))

(define (emit-vector op es si env)
  ;;; es are list of atomized subexpression
  (let ((sz (length es)))
    (emit op "mov ~a, %rcx" AP-REG)
    (emit op "movq $~a, (%rcx)" (immediate-rep sz))
    (emit op "add $~a, ~a" (align-to-multiple 8 (* (+ sz 1) WORDSIZE)) AP-REG)
    (for-each
      (lambda (i e)
        (emit-simple op e '%rax)
        (emit op "mov %rax, ~a(%rcx)" (* (+ i 1) WORDSIZE)))
      (iota sz)
      es)
    (emit op "mov %rcx, %rax")
    (emit op "or $~a, %rax" VEC-TAG)))

(define (emit-simple op e dest)
  (match e
    (,()
     (guard (immediate? e))
     (emit op "mov $~a, ~a" (immediate-rep e) dest))
    ((quote ())
     (emit op "mov $~a, ~a" (immediate-rep '()) dest))
    ((global ,lbl)
     (emit op "mov ~a, ~a" lbl dest))
    ((label ,lbl)
     (emit op "mov ~a, ~a" lbl dest))
    ((local-ref ,i)
     (guard (integer? i))
     (emit op "mov ~a(%rsp), ~a" (* (- WORDSIZE) (+ i 2)) dest))
    (,() (error "emit-simple" "unmatch" e))))

(define (emit-prim op e si env)
  (match e
    ((%walk-stack)
     (emit-walk-stack op -1 si env))
    ((%walk-stack ,e)
     (emit-walk-stack op e si env))
    ((align-to-multiple 8 ,e)
     (emit-expr op e si env)
     (emit-simple op e '%rax)
     (emit op "add $~a, %rax" (immediate-rep (- 8 1)))
     (emit op "and $~a, %rax" (immediate-rep -8)))
    ((eof-object)
     (emit op "mov $~a, %rax" EOF-TAG))
    ((eof-object? ,e)
     (emit-simple op e '%rax)
     (emit op "and $~a, %rax" IMM-MASK)
     (emit-eax=? op EOF-TAG))
    ((integer? ,e)
     (emit-simple op e '%rax)
     (emit op "and $~a, %rax" FIXNUM-MASK)
     (emit-eax=? op FIXNUM-TAG))
    ((boolean? ,e)
     (emit-simple op e '%rax)
     (emit op "and $~a, %rax" IMM-MASK)
     (emit-eax=? op BOOL-TAG))
    ((char? ,e)
     (emit-simple op e '%rax)
     (emit op "and $~a, %rax" IMM-MASK)
     (emit-eax=? op CHAR-TAG))
    ((char->integer ,e)
     (emit-simple op e '%rax)
     (emit op "sar $~a, %rax" (- IMM-SHIFT FIXNUM-SHIFT)))
    ((integer->char ,e)
     (emit-simple op e '%rax)
     (emit op "sal $~a, %rax" (- IMM-SHIFT FIXNUM-SHIFT))
     (emit op "or $~a, %rax" CHAR-TAG))
    ((,cmp ,e1 ,e2)
     (guard (assoc cmp suffix-cmp))
     (emit-cmp op cmp e1 e2 si env))
    ((- ,e)
     (emit-simple op e '%rax)
     (emit op "neg %rax"))
    ((- ,e1 ,e2)
     (emit-simple op e2 '%rcx)
     (emit-simple op e1 '%rax)
     (emit op "sub %rcx, %rax"))
    ((+ ,e1 ,e2)
     (emit-simple op e2 '%rcx)
     (emit-simple op e1 '%rax)
     (emit op "add %rcx, %rax"))
    ((* ,e1 ,e2)
     (emit-simple op e2 '%rcx)
     (emit-simple op e1 '%rax)
     (emit op "sar $~a, %rax" FIXNUM-SHIFT)
     (emit op "imul %rcx, %rax"))
    ((fxabs ,e1)
     (emit-simple op e1 '%rax)
     (emit op "mov %rax, %rcx")
     (emit op "neg %rcx")
     (emit op "cmovg %rcx, %rax"))
    ((fxmax ,e1 ,e2)
     (emit-simple op e2 '%rcx)
     (emit-simple op e1 '%rax)
     (emit op "cmp %rax, %rcx")
     (emit op "cmovg %rcx, %rax"))
    ((fixnum-width)
     (emit op "mov $~a, %rax" (immediate-rep (- (ash WORDSIZE 3) 3))))
    ((fxlength ,e1)
     ;;; TODO: simplify this
     (emit-prim op `(fxabs ,e1) si env)
     (emit op "or $~a, %rax" FIXNUM-MASK)
     (emit op "lzcnt %rax, %rax")
     (emit op "neg %rax")
     (emit op "add $~a, %rax" (- (ash WORDSIZE 3) 3))
     (emit op "sal $~a, %rax" FIXNUM-SHIFT))
    ((div ,dividend ,divisor)
     #;((div (* t x) (* t y))
        => (div x y)
        => (tag (div x y)))
     (emit-simple op divisor '%rcx)
     (emit-simple op dividend '%rax)
     (emit op "cqo")
     (emit op "idiv %rcx")
     (emit op "sal $~a, %rax" FIXNUM-SHIFT))
    ((mod ,dividend ,divisor)
     ;;; TODO: don't know why this works?
     (emit-expr op divisor si env)
     (emit-simple op divisor '%rcx)
     (emit-simple op dividend '%rax)
     (emit op "cqo")
     (emit op "idiv %rcx")
     (emit op "mov %rdx, %rax"))
    ((ashl ,e1 ,e2)
     (emit-simple op e2 '%rcx)
     (emit-simple op e1 '%rax)
     (emit op "sar $~a, %rcx" FIXNUM-SHIFT)
     (emit op "sal %cl, %rax"))
    ((ashr ,e1 ,e2)
     (emit-simple op e2 '%rcx)
     (emit-simple op e1 '%rax)
     (emit op "sar $~a, %rcx" FIXNUM-SHIFT)
     (emit op "sar $~a, %rax" FIXNUM-SHIFT)
     (emit op "sar %cl, %rax")
     (emit op "sal $~a, %rax" FIXNUM-SHIFT))
    ((bitwise-and ,e1 ,e2)
     (emit-simple op e2 '%rcx)
     (emit-simple op e1 '%rax)
     (emit op "and %rcx, %rax"))
    ((bitwise-ior ,e1 ,e2)
     (emit-simple op e2 '%rcx)
     (emit-simple op e1 '%rax)
     (emit op "or %rcx, %rax"))
    ((null? ,e)
     (emit-simple op e '%rax)
     (emit op "and $~a, %rax" IMM-MASK)
     (emit-eax=? op NIL-TAG))
    ((pair? ,e)
     (emit-simple op e '%rax)
     (emit op "and $~a, %rax" PTR-MASK)
     (emit-eax=? op PAIR-TAG))
    ((cons ,simp1 ,simp2)
     (emit op "mov ~a, %rcx" AP-REG)
     (emit op "add $~a, ~a" (* 2 WORDSIZE) AP-REG)
     (emit-expr op simp2 si env)
     (emit op "mov %rax, ~a(%rcx)" WORDSIZE)
     (emit-expr op simp1 si env)
     (emit op "mov %rax, (%rcx)")
     (emit op "mov %rcx, %rax")
     (emit op "or $~a, %rax" PAIR-TAG))
    ((car ,e)
     (emit-simple op e '%rax)
     (emit op "mov ~a(%rax), %rax" (- PAIR-TAG)))
    ((cdr ,e)
     (emit-simple op e '%rax)
     (emit op "mov ~a(%rax), %rax" (- WORDSIZE PAIR-TAG)))
    ((set-car! ,e ,v)
     (emit-simple op v '%rcx)
     (emit-simple op e '%rax)
     (emit op "mov %rcx, ~a(%rax)" (- PAIR-TAG)))
    ((set-cdr! ,e ,v)
     (emit-simple op v '%rcx)
     (emit-simple op e '%rax)
     (emit op "mov %rcx, ~a(%rax)" (- WORDSIZE PAIR-TAG)))
    ((string? ,e)
     (emit-simple op e '%rax)
     (emit op "and $~a, %rax" PTR-MASK)
     (emit-eax=? op STR-TAG))
    ((make-string ,sz ,ch)
     (emit op "mov ~a, (free_ptr)" AP-REG)
     (emit-foreign-call op 's_make_string (list sz ch) si env)
     (emit op "mov (free_ptr), ~a" AP-REG))
    ((string-length ,s)
     (emit-simple op s '%rax)
     (emit op "mov ~a(%rax), %rax" (- STR-TAG)))
    ((string-set! ,s ,i ,v)
     (emit-simple op s '%rax)
     (emit-simple op i '%rcx)
     (emit op "sar $~a, %rcx" FIXNUM-SHIFT) ; remove fixnum mask
     (emit op "add %rcx, %rax")
     (emit-simple op v '%rcx)
     (emit op "sar $~a, %rcx" IMM-SHIFT) ; remove char mask
     (emit op "movb %cl, ~a(%rax)" (- WORDSIZE STR-TAG))
     (emit op "xor %rax, %rax"))
    ((string-ref ,s ,i)
     (emit-simple op s '%rax)
     (emit-simple op i '%rcx)
     (emit op "sar $~a, %rcx" FIXNUM-SHIFT) ; remove fixnum mask
     (emit op "add %rcx, %rax")
     (emit op "movzbq ~a(%rax), %rax" (- WORDSIZE STR-TAG))
     (emit op "sal $~a, %rax" IMM-SHIFT)
     (emit op "or $~a, %rax" CHAR-TAG))
    ((vector? ,e)
     (emit-simple op e '%rax)
     (emit op "and $~a, %rax" PTR-MASK)
     (emit-eax=? op VEC-TAG))
    ((vector . ,es)
     (emit-vector op es si env))
    ((vector-length ,e)
     (emit-simple op e '%rax)
     (emit op "mov ~a(%rax), %rax" (- VEC-TAG)))
    ((make-vector ,sz)
     (emit op "mov ~a, (free_ptr)" AP-REG)
     (emit-foreign-call op 's_make_vector (list sz) si env)
     (emit op "mov (free_ptr), ~a" AP-REG))
    ((vector-ref ,v ,i)
     (emit-simple op i '%rcx)
     (emit-simple op v '%rax)
     (emit op "add %rcx, %rax")
     (emit op "mov ~a(%rax), %rax" (- WORDSIZE VEC-TAG)))
    ((vector-set! ,v ,i ,e)
     (emit-simple op i '%rcx)
     (emit-simple op v '%rax)
     (emit op "add %rcx, %rax")
     (emit-simple op e '%rcx)
     (emit op "mov %rcx, ~a(%rax)" (- WORDSIZE VEC-TAG))
     (emit op "mov %rcx, %rax"))
    ((procedure? ,e)
     (emit-simple op e '%rax)
     (emit op "and $~a, %rax" PTR-MASK)
     (emit-eax=? op CLOS-TAG))
    ((symbol? ,e)
     (emit-simple op e '%rax)
     (emit op "and $~a, %rax" PTR-MASK)
     (emit-eax=? op SYM-TAG))
    ((%string->symbol ,e)
     (emit-simple op e '%rax)
     (emit op "add $~a, %rax" (- SYM-TAG STR-TAG)))
    ((%symbol->string ,e)
     (emit-simple op e '%rax)
     (emit op "sub $~a, %rax" (- SYM-TAG STR-TAG)))
    (,() (error "emit-prim" "unmatch" e))))

(define (emit-walk-stack op e si env)
  ;;; e is atomic expression
  ;;; NOTE:
  ;;; The procedure assume esp is the frame pointer
  ;;; And top stack pointer implied by the si parameter
  ;;; gc_flip(word_t fx_size, word_t *esp, word_t *ebp)
  (define (emit-call-gc-flip)
    (emit op "mov ~a, (free_ptr)" AP-REG)
     (emit op "mov %rsp, %rbx")
     (emit op "mov %rax, %rdi") ; fx_size
     (emit op "lea ~a(%rsp), %rsi" (- (- (abs si) WORDSIZE)))  ; store the stack pointer, esp
     (emit op "mov %rsp, %rdx")                                ; store the frame pointer, ebp
     (emit op "sub $~a, %rsp" (- (abs si) WORDSIZE))           ; substract esp
     (emit op "and $-16, %rsp")
     (emit op "call gc_flip")
     (emit op "mov %rbx, %rsp")
     (emit op "mov (free_ptr), ~a" AP-REG)
     ;;; NOTE: Restore back the closure pointer after GC
     (emit op "mov ~a(%rsp), ~a" (- WORDSIZE) CLOS-REG))
  (cond
    ((not (integer? si))
     (error "emit-walk-stack" "unknown" si))
    ((eq? e -1)
     (emit-simple op e '%rax)
     (emit-call-gc-flip))
    (else
     (let ((cont (generate-label "cont"))
           (altern (generate-label "altern")))
        (emit-simple op e '%rax)
        ; max(sz,k) == sz < k ? k : sz
        ; sz < k ~> %rax < k
        (emit op "cmp $~a, %rax" (immediate-rep GC-CTX-MIN-SIZE))
        (emit op "jge ~a" altern)
        (emit op "mov $~a, %rax" (immediate-rep GC-CTX-MIN-SIZE))
        (emit op "~a: " altern)
        ;;; fromspace_end - free_ptr
        (emit op "mov (fromspace_end), %rcx")
        (emit op "sub ~a, %rcx" AP-REG)
        (emit op "sal $~a, %rcx" FIXNUM-SHIFT)
        ; %rax < %rcx
        (emit op "cmp %rcx, %rax")
        (emit op "jl ~a" cont)
        (emit-call-gc-flip)
        (emit op "jmp ~a" cont)
        (emit op "~a: " cont)))))

(define (emit-tail-call op maybe-decl fn args si env)
  (let* ((argc (length (cons fn args)))
         (calc-offset (lambda (i) (- si (* WORDSIZE i)))))
    (for-each
      (lambda (offset arg)
        (emit-simple op arg '%rax)
        (emit op "mov %rax, ~a(%rsp)" offset))
      (map calc-offset (iota argc))
      (cons fn args))
    ;;; copying the memory
    (for-each
      (lambda (i)
        (emit op "mov ~a(%rsp), %rax" (calc-offset i))
        (emit op "mov %rax, ~a(%rsp)" (* (- WORDSIZE) (+ i 1))))
      (iota argc))
    (emit op "mov $~a, %rcx" argc)
    (match maybe-decl
      ((label ,lbl)
       (emit op "add $~a, %rsp" WORDSIZE)
       (emit op "jmp ~a" lbl))
      (#f
       (emit op "mov ~a(%rsp), %rax" (- WORDSIZE))
       (emit op "mov ~a(%rax), %rax" (- CLOS-TAG))
       (emit op "add $~a, %rsp" WORDSIZE)
       (emit op "jmp *%rax"))
      (,() (error "emit-tail-call" "unmatch" maybe-decl)))))

(define (emit-call op maybe-decl fn args si env)
  (let* ((argc (length (cons fn args)))
         (start-si (- si (* 2 WORDSIZE)))
         (calc-offset (lambda (i) (- start-si (* WORDSIZE i)))))
    (emit op "movq $0, ~a(%rsp)" si)
    ;;; this store the frame pointer
    (emit op "movq %rsp, ~a(%rsp)" (- si WORDSIZE))
    (for-each
      (lambda (offset arg)
        (emit-simple op arg '%rax)
        (emit op "mov %rax, ~a(%rsp)" offset))
      (map calc-offset (iota argc))
      (cons fn args))
    (emit op "mov $~a, %rcx" argc)
    (match maybe-decl
      ((label ,lbl)
       (emit op "sub $~a, %rsp" (- (abs si) WORDSIZE))
       (emit op "call ~a" lbl))
      (#f
       (emit op "mov ~a(%rsp), %rax" start-si)
       (emit op "mov ~a(%rax), %rax" (- CLOS-TAG))
       (emit op "sub $~a, %rsp" (- (abs si) WORDSIZE))
       (emit op "call *%rax"))
      (,() (error "emit-call" "unmatch" maybe-decl)))
    (emit op "add $~a, %rsp" (- (abs si) WORDSIZE))
    (emit op "mov ~a(%rsp), ~a" (- WORDSIZE) CLOS-REG)))

(define (emit-foreign-call op fn args si env)
  (let* ((argc (length args))
         (end-si si))
    (let loop ((args args) (regs REGISTERS))
      (if (pair? args)
          (begin
            (emit-simple op (car args) (car regs))
            (loop (cdr args) (cdr regs)))))
    (emit op "mov %rsp, %rbx")
    (emit op "sub $~a, %rsp" (abs end-si))
    (emit op "and $-16, %rsp")
    (emit op "call ~a" fn)
    (emit op "mov %rbx, %rsp")))

(define (emit-tail-apply op fn es si env)
  (emit-simple op fn '%rcx)
  (emit-simple op es '%rax)
  (emit op "mov %rax, ~a(%rsp)"  (- (* 2 WORDSIZE)))
  (emit op "mov %rcx, ~a(%rsp)" (- WORDSIZE))
  (emit op "add $~a, %rsp" WORDSIZE)
  (emit op "jmp L_apply"))

(define (emit-apply op fn es si env)
  (emit op "mov %rsp, ~a(%rsp)" (- si WORDSIZE))
  (emit-simple op fn '%rax)
  (emit op "mov %rax, ~a(%rsp)" (- si (* 2 WORDSIZE)))
  (emit-simple op es '%rax)
  (emit op "mov %rax, ~a(%rsp)" (- si (* 3 WORDSIZE)))
  (emit op "sub $~a, %rsp" (- (abs si) WORDSIZE))
  (emit op "call L_apply")
  (emit op "add $~a, %rsp" (- (abs si) WORDSIZE))
  (emit op "mov ~a(%rsp), ~a" (- WORDSIZE) CLOS-REG))

(define (emit-L-apply op)
  (let ((loop (generate-label "unstack"))
        (end (generate-label "call")))
    (emit op ".p2align 3")
    (emit op "L_apply: ")
    (emit op "mov ~a(%rsp), %rcx" (- (* 3 WORDSIZE)))
    (emit op "lea ~a(%rsp), %rdx" (- (* 3 WORDSIZE)))
    (emit op "~a: " loop)
    (emit op "cmp $~a, %rcx" NIL-TAG)
    (emit op "je ~a" end)

    (emit op "mov ~a(%rcx), %rax" (- PAIR-TAG))
    (emit op "mov %rax, (%rdx)")

    (emit op "mov ~a(%rcx), %rcx" (- WORDSIZE PAIR-TAG))
    (emit op "sub $~a, %rdx" WORDSIZE)
    (emit op "jmp ~a" loop)
    (emit op "~a: " end)
    (emit op "lea ~a(%rsp), %rcx" (- (* 3 WORDSIZE)))
    (emit op "sub %rdx, %rcx")
    (emit op "sar $~a, %rcx" FIXNUM-SHIFT)
    (emit op "add $1, %rcx")
    (emit op "mov ~a(%rsp), %rax" (- (* 2 WORDSIZE)))
    (emit op "mov ~a(%rax), %rax" (- CLOS-TAG))
    (emit op "jmp *%rax")
  ))
(define (emit-construct-vararg op argc si)
  #;(
      [z 1]
      ()  0
      (1) 1

      [(x y . z) 3]
      (0)           1   err
      (0 1)         2   (0 1 ())
      (0 1 2)       3   (0 1 (2))
      (0 1 2 3)     4   (0 1 (2 3))
      (0 1 2 3 4)   5   (0 1 (2 3 4))
      
      example
      inp         cons    argc  sz
      (0 1 2 3 4) ()      5     3
      (0 1 2 3)   (4)     4     3
      (0 1 2)     (3 4)   3     3
      (0 1)       (2 3 4) 2     3
  )
  (emit op "mov ~a, (free_ptr)" AP-REG)
  (emit op "mov %rsp, %rbx")
  (emit op "sal $~a, %rcx" FIXNUM-SHIFT)
  (emit op "sub %rcx, %rsp")

  (emit op "mov %rsp, %rdx")       ; esp
  (emit op "mov %rcx, %rsi")       ; argc
  (emit op "mov %rbx, %rcx")       ; ebp
  (emit op "mov $~a, %rdi" argc)   ; expected argc
  (emit op "and $-16, %rsp")
  (emit op "call construct_vararg")
  (emit op "mov %rbx, %rsp") ; restore the frame pointer
  (emit op "mov %rax, ~a(%rsp)" (* (- WORDSIZE) argc))
  (emit op "mov (free_ptr), ~a" AP-REG))

(define (emit-procedure op fn params variadic? fvs body)
  (let* ((argc (length params))
         (env (make-env))
         (si (* (- WORDSIZE) (+ argc 1))))
    (emit op ".p2align 3")
    (emit op ".globl ~a" fn)
    (emit op ".type ~a, @function" fn)
    (emit op "~a: " fn)
    (emit op "sub $~a, %rsp" WORDSIZE)
    (if (not variadic?)
        (let ((end (generate-label 'conseq)))
          (emit op "cmp $~a, %rcx" argc)
          (emit op "je ~a" end)
          (emit-foreign-call op 's_proc_arg_err '() si env)
          (emit op "~a: " end))
        (emit-construct-vararg op argc si))
    ;;; NOTE: first argument is always the closure
    (emit op "mov ~a(%rsp), ~a" (- WORDSIZE) CLOS-REG)
    (match body
      (((alloca ,i) . ,body)
       (guard (and (integer? i) (<= (sub1 argc) i)))
       (for-each
          (lambda (i)
            (emit op "movq $0, ~a(%rsp)"
                     (* (- WORDSIZE) (+ i 2))))
          (filter (lambda (i) (<= argc i)) (iota i)))
       (emit-seq op body (* (- WORDSIZE) (+ i 2)) env))
      (,() (error "emit-procedure" "unknown body" body)))
    (emit op "add $~a, %rsp" WORDSIZE)
    (emit op "ret")))

(define (emit-variadic-procedure op fn fvs clauses)
  (let* ((env (make-env)))
    (emit op ".p2align 3")
    (emit op ".globl ~a" fn)
    (emit op ".type ~a, @function" fn)
    (emit op "~a: " fn)
    (emit op "mov ~a(%rsp), ~a" (- (* WORDSIZE 2)) CLOS-REG)
    (for-each
      (lambda (clause)
        (match clause
          ((closure ,fn ,fvs ,variadic? ,argc)
           (let ((next (generate-label "case_lambda_altern")))
            (cond
              (variadic?
               (emit op "cmp $~a, %rcx" (sub1 argc))
               (emit op "jl ~a" next))
              (else
               (emit op "cmp $~a, %rcx" argc)
               (emit op "jne ~a" next)))
            (emit op "mov %rcx, %rdx")
            (emit-closure op fn fvs #f env)
            (emit op "mov %rax, ~a(%rsp)" (- (* WORDSIZE 2)))
            (emit op "mov %rdx, %rcx")
            (emit op "jmp ~a" fn)
            (emit op "~a: " next)))
          (,() (error "emit-variadic-procedure" "unknown clause" clause))))
      clauses)
    (emit-foreign-call op 's_proc_arg_err '() (- (* 2 WORDSIZE)) env)))

(define (emit-closure op fn fvs si env)
  (define fvs-count (length fvs))
  (emit op "mov ~a, %rcx" AP-REG)
  (emit op "add $~a, ~a"
            (align-to-multiple 8 (* WORDSIZE (+ 2 fvs-count)))
            AP-REG)
  (emit op "mov $~a, %rax" fn)
  (emit op "mov %rax, (%rcx)")
  (emit op "movq $~a, ~a(%rcx)" (immediate-rep fvs-count) WORDSIZE)
  (for-each
    (lambda (fv i)
      (emit-expr op fv si env)
      (emit op "mov %rax, ~a(%rcx)"
              (* WORDSIZE (+ 2 i))))
    fvs
    (iota fvs-count))
  (emit op "mov %rcx, %rax")
  (emit op "or $~a, %rax" CLOS-TAG))

(define (emit-seq op es si env)
  (for-each
    (lambda (e) (emit-expr op e si env))
    es))

(define (emit-expr op e si env)
  (match e
    (,()
     (guard (immediate? e))
     (emit op "mov $~a, %rax" (immediate-rep e)))
    (,()
     (guard (string? e))
     (emit-str-lit op e si))
    #;
    (,()
     (guard (symbol? e))
     (emit op "mov ~a, %rax" (apply-env e env)))
    ;;; NOTE:
    ;;; Suppose wordsize=4
    ;;; (%rsp) points to frame pointer, -4(%rsp) points to closure pointer
    ;;; therefore, first local (i = 0) starts at (-4 * (+ 0 2))(%rsp) = -8(%rsp)
    ((local-set! ,i ,e)
     (guard (integer? i))
     (emit-expr op e si env)
     (emit op "mov %rax, ~a(%rsp)" (* (- WORDSIZE) (+ i 2))))
    ((local-ref ,i)
     (guard (integer? i))
     (emit op "mov ~a(%rsp), %rax" (* (- WORDSIZE) (+ i 2))))
    ((quote ())
     (emit op "mov $~a, %rax" (immediate-rep '())))
    ((collect ,sz)
     (emit-walk-stack op sz si env))
    ((global ,lbl)
     (emit op "mov ~a, %rax" lbl))
    ((label ,lbl)
     (emit op "mov ~a, %rax" lbl))
    ((closure-ref ,() ,i)
     (guard (integer? i))
     (emit op "mov ~a(~a), %rax" (- (* WORDSIZE (+ i 2)) CLOS-TAG) CLOS-REG))
    ((set-label! ,lbl ,e)
     (emit-expr op e si env)
     (emit op "mov %rax, ~a" lbl))
    ((begin . ,es)
     (emit-seq op es si env))
    ((if ,pred ,conseq ,altern)
     (emit-if op pred conseq altern si env))
    ((closure ,fn ,fvs)
     (emit-closure op fn fvs si env))
    ((call ,tail? (prim apply) ,fn ,es)
     ((if tail? emit-tail-apply emit-apply) op fn es si env))
    ((call ,() (prim ,pr) . ,es)
     (emit-prim op (cons pr es) si env))
    ((call ,tail? ,maybe-decl ,fn . ,es)
     ((if tail? emit-tail-call emit-call) op maybe-decl fn es si env))
    ((foreign-call ,fn . ,es)
     (emit-foreign-call op fn es si env))
    (,() (error "emit-expr" "unmatch" e))))

(define (emit-code op entry-name prog)
  (match prog
    ((program (labels . ,labels)
              (data . ,data)
              (unbounds . ,unbounds)
              ((alloca ,i) . ,body))
     ;;; NOTE:
     ;;; referenced operand position primitives are not externed here
     ;;; but dont know what are the risk
     (emit op ".globl ~a" entry-name)
     (emit op ".extern L_apply")
     (for-each (lambda (g) (emit op ".extern ~a" g)) (set-union data unbounds))
     (emit op ".section .text")
     (for-each
       (lambda (label)
         (match label
           ((,name (code ,params ,variadic? ,fvs ,e))
            (emit-procedure op name params variadic? fvs e))
           ((,name (case-code ,fvs . ,clauses))
            (emit-variadic-procedure op name fvs clauses))
           (,() (error "emit-code" "unmatch" label))))
       labels)
     (emit op "~a:" entry-name)
     (emit op "push %rbp")
     (emit op "mov %rsp, %rbp")
     (for-each
       (lambda (i) (emit op "movq $0, ~a(%rsp)" (* (- WORDSIZE) (+ i 1))))
       (iota (+ i 1)))
     (emit-seq op body (* (- WORDSIZE) (+ i 2)) (make-env))
     (emit op "mov $0, %rax")
     (emit op "pop %rbp")
     (emit op "ret"))
    (,() (error "emit-code" "unmatch" prog))))

(define (program->data prog)
  (match prog
    ((program (labels . ,()) (data . ,data) (unbounds . ,()) ,()) data)
    (,() (error "program->data" "unmatch" prog))))

(define (emit-obj input-path output-path k)
  (define tmp-filename (mk-tmpname (path-fileroot input-path) "s"))
  (let* ((prog (preprocess (cons 'begin (read-sexps-from-path input-path))))
         (entry-name (format "~a.main" (string->id-string (path-fileroot input-path))))
         (data (program->data prog))
         (op (open-output-file tmp-filename)))
    (emit-code op entry-name prog)
    (close-output-port op)
    (system* "~a ~a -c ~a -o ~a"
             CC CC-ARGS
             tmp-filename output-path)
    (system* "rm -f ~a" tmp-filename)
    (k entry-name data)))

(define (read-meta obj-file)
  (let* ((filename (mk-tmpname "read-meta" "txt"))
          (_ (system* "objcopy --dump-section .main_entry=~a ~a"
                      filename obj-file))
          (inp (open-input-file filename))
          (meta (read inp)))
    (close-port inp)
    (system* "rm -f ~a" filename)
    meta))

(define (map3-k f xs k)
  (let recur ((xs xs) (k k))
    (if (not (pair? xs))
        (k '() '() '())
        (f (car xs)
          (lambda (x y z)
            (recur (cdr xs)
              (lambda (xs ys zs)
                (k (cons x xs) (cons y ys) (cons z zs)))))))))

(define (mk-tmpname f ext)
  (format "/dev/shm/scm-build-~a-~a.~a" (path-fileroot f) (random-string 8) ext))

(define (emit-objs input-paths k)
  (map3-k
    (lambda (i k)
      (if (equal? (path-extension i) "o")
          (let ((out (mk-tmpname i "o")))
            (system* "cp ~a ~a" i out)
            (k out (read-meta out) (lambda () (system* "rm -f ~a" out))))
          (let ((out (mk-tmpname i "o")))
            (emit-obj i out
              (lambda (entry-name data) (k out (list (list entry-name) data) (lambda () (system* "rm -f ~a" out))))))))
    input-paths
    k))

(define (combine-objs output-path objs metas)
  (define entries (apply append (map car metas)))
  (define globals (apply set-union (map cadr metas)))
  (system* "~a ~a -r -o ~a ~a"
           CC CC-ARGS
           output-path
           (apply string-append
                  (map (lambda (s) (string-append " \"" s "\" ")) objs)))
  (system* "objcopy --remove-section=.main_entry --add-section .main_entry=<(echo ~s) ~a"
           (format "~s" (list entries globals))
           output-path))

(define (linking-to-exe output-path objs metas)
  (define (make-prim-call pr . es)
    `(call #f (prim ,pr) . ,es))
  (define (make-box-init e)
    (make-prim-call 'cons e '(quote ())))
  (define entries (apply append (map car metas)))
  (define globals (apply set-union (map cadr metas)))
  (define tmp-filename (mk-tmpname (string-append (path-fileroot output-path) "-exec") "s"))
  (let* ((op (open-output-file tmp-filename)))
    (emit op ".globl main")
    (emit op ".globl L_apply")
    (for-each (lambda (g) (emit op ".globl ~a" g)) globals)

    (emit op ".section .data")
    (emit op ".globl global_table")
    (emit op "global_table:")
    (for-each
      (lambda (g) (emit op ".~abyte ~a" WORDSIZE g))
      globals)
    (emit op ".~abyte 0" WORDSIZE)
    (for-each
      (lambda (g)
      (match g
        (,()
         (guard (symbol? g))
         (emit op ".p2align 3")
         (emit op "~a: .~abyte 0" g WORDSIZE))
        (,() (error "linking-to-exe" "unmatch" g))))
      globals)
    (emit op ".section .text")
    (emit-L-apply op)
    (emit op "main:")
    (emit op "mov %rsp, BOT_EBP")
    (emit op "mov %rsp, %rbp")
    (emit op "mov %rsi, ARGV")
    (emit op "mov %rdi, ARGC")
    (emit op "call init_heap")
    (emit op "mov (free_ptr), ~a" AP-REG)
    (emit op "# globals")
    (for-each
      (lambda (g)
        (emit-expr op `(set-label! ,g ,(make-box-init 0)) (- WORDSIZE) #f))
      globals)
    (emit op "# end of globals")
    (for-each
      (lambda (entry) (emit op "call ~a" entry))
      entries)
    (emit op "mov $0, %rax")
    (emit op "ret")
    (close-output-port op))
  (system* "~a ~a ~a ~a runtime.o -o ~a"
           CC CC-ARGS
           tmp-filename
           (apply string-append
                  (map (lambda (s) (string-append " \"" s "\" ")) objs))
            output-path)
  (system* "rm -f ~a" tmp-filename))

(match (cdr (command-line))
  (("-o" ,output-path . ,input-paths)
   (emit-objs input-paths
    (lambda (objs metas frees)
      ((if (equal? (path-extension output-path) "o") combine-objs linking-to-exe) output-path objs metas)
      (map (lambda (f) (f)) frees))))
  (("--make-prim-lib" ,output-path)
   (write-primitive-lib output-path))
  ((,input-path . ,input-paths)
   (emit-objs (cons input-path input-paths)
    (lambda (objs metas frees)
      (let ((output-path (mk-tmpname "tmp" "out")))
        (linking-to-exe output-path objs metas)
        (system* output-path)
        (system* "rm -f ~a" output-path)
        (map (lambda (f) (f)) frees)))))
  (,cmd-ln (error (car (command-line)) "unmatch" cmd-ln)))
)