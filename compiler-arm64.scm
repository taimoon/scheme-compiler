(import
  (only (desugar) write-primitive-lib)
  (only (front) preprocess)
  (only (match) match)
  (only (set) make-set set-union set-diff)
  (only (utils)
    make-env extend-env maybe-apply-env apply-env
    read-sexps-from-path align-to-multiple
    random-string symbol->id-symbol string->id-string generate-label
    system*
    path-fileroot path-filename mk-tmpname))

(let ()
; https://github.com/ARM-software/abi-aa/releases/download/2025Q1/aapcs64.pdf
; https://github.com/ARM-software/abi-aa/releases/download/2025Q1/sysvabi64.pdf
; https://pages.cs.wisc.edu/~markhill/restricted/arm_isa_quick_reference.pdf
#;(arm64
calling-layout
; https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/using-the-stack-in-aarch32-and-aarch64
For AArch64, sp must be 16-byte aligned whenever it is used to access memory. This is enforced by AArch64 hardware.
sp always points top value and not the free cell
(... ra fp/sp arg-0/clos arg-1 ... arg-n local-0 ... n)
; procedure - n = #local + #arg
(...
  ra      1
  fp/sp   0    (aligned at 16 bytes)
  clos    -1
  arg-1   -2
  ...
  arg-i   -(2+i)
  si      -(2+n)
  )
; file entry - n = #local
(...
  xzr         2
  lr          1
  fp/sp       0    (aligned at 16 bytes) [sp]
  clos/xzr    -1
  lcl-0       -2
  ...
  lcl-i       -(2+i)
  ;;; NOTE: the parameter `si` is at -8 from 16-byte aligned stack
  lr          -(2+n)
  fp          -(3+n)
  ...
  )
)
(define REGISTERS '(x0 x1 x2 x3 x4 x5 x6 x7))
(define TEMPORARIES (list->vector '(x9 x10 x11 x12 x13 x14 x15)))
(define IP0 'r16)
(define IP1 'r17)
(define PLATFORM-REG 'r18)
(define CALLEE-SAVED-REGS '(x19 x20 x21 x22 x23 x24 x25 x26 x27 x28))
(define FRAME-POINTER '(x29 fp))
(define LINK-REGISTER '(x30 lr))
(define STACK-POINTER 'sp)
(define FIXNUM-MASK   #b00000111)
(define FIXNUM-TAG    #b00000000)
(define FIXNUM-SHIFT  3)
(define IMM-SHIFT     8)
(define IMM-MASK      #b11111111)
(define IMM-TAG       #b00000111)
(define EOF-TAG       #b00000111)
(define CHAR-TAG      #b00001111)
(define BOOL-TAG      #b00011111)
(define NIL-TAG       #b00111111)
(define FALSE-IMM     BOOL-TAG)
(define TRUE-IMM      (bitwise-ior (ash 1 IMM-SHIFT) BOOL-TAG))
(define PTR-MASK      #b00000111)
(define PAIR-TAG      #b00000001)
(define VEC-TAG       #b00000010)
(define STR-TAG       #b00000011)
(define SYM-TAG       #b00000101)
(define CLOS-TAG      #b00000110)
(define GC-CTX-MIN-SIZE 64)
; riscv64-linux-gnu-as
(define (maybe-getenv name default)
  (let ((val (getenv name)))
    (if val val default)))
(define CC (maybe-getenv "CC" "gcc"))
; -march=rv64gc_zbb support cound leading zero instructions
(define CC-ARGS "-g -fno-omit-frame-pointer")
(define OBJCOPY (maybe-getenv "OBJCOPY" "objcopy"))

(define WORDSIZE 8)
(define CLOS-REG 'x19)
(define AP-REG 'x20)

;;; emit
(define (emit op . args)
  (apply format (cons op args))
  (newline op))

(define (immediate? v)
  (or (integer? v) (boolean? v) (char? v)))

(define (immediate-rep imm)
  (cond
    ((char? imm)
     (bitwise-ior CHAR-TAG
                  (ash (char->integer imm)
                       IMM-SHIFT)))
    ((boolean? imm)
     (if imm TRUE-IMM FALSE-IMM))
    ((integer? imm)
     (ash imm FIXNUM-SHIFT))
    ((null? imm)
     NIL-TAG)
    (else (error "immediate-rep" "unknown immediate" imm))))

(define (emit-eax=? op v)
  (emit op "cmp x0, ~a" v)
  (emit op "cset x0, eq")
  (emit op "lsl x0, x0, ~a" IMM-SHIFT)
  (emit op "orr x0, x0, ~a" BOOL-TAG))

(define suffix-cmp
  '((< lt)
    (<= le)
    (= eq)
    (eq? eq)
    (> gt)
    (>= ge)))

(define (emit-cmp op cmp e1 e2 si env)
  (emit-simple op e1 'x0)
  (emit-simple op e2 'x1)
  (emit op "cmp x0, x1")
  (emit op "cset x0, ~a" (cadr (assq cmp suffix-cmp)))
  (emit op "lsl x0, x0, ~a" IMM-SHIFT)
  (emit op "orr x0, x0, ~a" BOOL-TAG))

(define (emit-if op pred conseq altern si env)
  (let ((end-label (generate-label "end"))
        (altern-label (generate-label "altern")))
    (emit-expr op pred si env)
    (emit op "cmp x0, ~a" FALSE-IMM)
    (emit op "beq ~a" altern-label)
    ;;; NOTE: for debugging purpose
    (emit op "~a :" (generate-label "conseq"))
    (emit-expr op conseq si env)
    (emit op "b ~a" end-label)
    (emit op "~a: " altern-label)
    (emit-expr op altern si env)
    (emit op "~a: " end-label)))

(define (emit-str-lit op s si)
  (emit op "mov x0, ~a" AP-REG)
  (emit op "mov x1, ~a" (align-to-multiple 8 (+ WORDSIZE (+ 1 (string-length s)))))
  (emit op "add ~a, ~a, x1" AP-REG AP-REG)
  ;; store string length
  (emit op "mov x1, ~a" (immediate-rep (string-length s)))
  (emit op "str x1, [x0]") ; store length at start
  (for-each
    (lambda (i)
      (emit op "mov w1, ~a" (char->integer (string-ref s i)))
      (emit op "strb w1, [x0, ~a]" (+ WORDSIZE i)))
    (iota (string-length s)))
  ;; null terminator
  (emit op "strb wzr, [x0, ~a]" (+ WORDSIZE (string-length s)))
  ;; tag pointer in x0
  (emit op "orr x0, x0, ~a" STR-TAG))

(define (emit-vector op es si env)
  ;;; es are list of atomized subexpression
  (let ((sz (length es)))
    (emit op "mov x0, ~a" AP-REG)
    (emit op "add ~a, ~a, ~a" AP-REG AP-REG (align-to-multiple 8 (* (+ sz 1) WORDSIZE)))
    (load-immediate op 'x1 (immediate-rep sz))
    (emit op "str x1, [x0]")
    (for-each
      (lambda (i e)
        (emit-simple op e 'x1)
        (emit op "str x1, [x0, ~a]" (* (+ i 1) WORDSIZE)))
      (iota sz)
      es)
    (emit op "orr x0, x0, ~a" VEC-TAG)))

(define (store-to-label op src-reg dst-lbl)
  (emit op "ldr x9, =~a" dst-lbl)
  (emit op "str ~a, [x9]" src-reg))

(define (load-from-label op dst-reg src-lbl)
  (emit op "ldr ~a, =~a" dst-reg src-lbl)
  (emit op "ldr ~a, [~a]" dst-reg dst-reg))

(define (load-immediate op dst fx)
  (cond
    ((not (integer? fx))
     (error "load-immediate" "expect-only-fixnum" fx))
    ((< fx 0)
     (load-immediate op dst (- fx))
     (emit op "neg ~a, ~a" dst dst))
    (else
     (let ((lo (bitwise-and fx (- (ash 1 16) 1)))
           (hi (ash fx -16)))
      (emit op "movz ~a, ~a" dst lo)
      (if (> hi 0)
          (emit op "movk ~a, ~a, lsl ~a" dst hi 16))))))

(define (emit-store op src base offset temp)
  (cond
    ((not (integer? offset))
     (error "emit-store" "expect-integer-offset" offset))
    ((not (= 0 (bitwise-and offset (- WORDSIZE 1))))
     (error "emit-store" "expect-offset-multiple-of-wordsize"))
    ((and (<= -256 offset) (<= offset 255))
     (emit op "str ~a, [~a, ~a]" src base offset))
    (else
     (emit op "mov ~a, ~a" temp (ash offset (- FIXNUM-SHIFT)))
     (emit op "str ~a, [~a, ~a, lsl ~a]" src base temp FIXNUM-SHIFT))))

(define (emit-load op dest base offset temp)
  (cond
    ((not (integer? offset))
     (error "emit-load" "expect-integer-offset" offset))
    ((not (= 0 (bitwise-and offset (- WORDSIZE 1))))
     (error "emit-load" "expect-offset-multiple-of-wordsize"))
    ((and (<= -256 offset) (<= offset 255))
     (emit op "ldr ~a, [~a, ~a]" dest base offset))
    (else
     (emit op "mov ~a, ~a" dest (ash offset (- FIXNUM-SHIFT)))
     (emit op "ldr ~a, [~a, ~a, lsl ~a]" dest base dest FIXNUM-SHIFT))))

;;; mov cannot load big immediates
(define (emit-simple op e dest)
  (match e
    (,()
     (guard (immediate? e))
     (load-immediate op dest (immediate-rep e)))
    ((quote ())
     (load-immediate op dest (immediate-rep '())))
    ((global ,lbl)
     (load-from-label op dest lbl))
    ((label ,lbl)
     (load-from-label op dest lbl))
    ((local-ref ,i)
     (guard (integer? i))
     (emit-load op dest 'sp (* (- WORDSIZE) (+ i 2)) (vector-ref TEMPORARIES 0)))
    ;;; TODO: closure-ref shouldn't be simple
    ((closure-ref ,() ,i)
     (guard (integer? i))
     (emit op "add ~a, ~a, ~a" dest CLOS-REG (- (* WORDSIZE (+ i 2)) CLOS-TAG))
     (emit op "ldr ~a, [~a]" dest dest))
    (,() (error "emit-simple" "unmatch" e))))

(define (emit-prim op e si env)
  (match e
    ((%walk-stack)
     (emit-walk-stack op -1 si env))
    ((%walk-stack ,e)
     (emit-walk-stack op e si env))
    ((align-to-multiple 8 ,e)
     (emit-simple op e 'x0)
     (emit op "add x0, x0, ~a" (immediate-rep (- 8 1)))
     (emit op "and x0, x0, ~a" (immediate-rep -8)))
    ((eof-object)
     (emit op "mov x0, ~a" EOF-TAG))
    ((eof-object? ,e)
     (emit-simple op e 'x0)
     (emit op "and x0, x0, ~a" IMM-MASK)
     (emit-eax=? op EOF-TAG))
    ((integer? ,e)
     (emit-simple op e 'x0)
     (emit op "and x0, x0, ~a" FIXNUM-MASK)
     (emit-eax=? op FIXNUM-TAG))
    ((boolean? ,e)
     (emit-simple op e 'x0)
     (emit op "and x0, x0, ~a" IMM-MASK)
     (emit-eax=? op BOOL-TAG))
    ((char? ,e)
     (emit-simple op e 'x0)
     (emit op "and x0, x0, ~a" IMM-MASK)
     (emit-eax=? op CHAR-TAG))
    ((char->integer ,e)
     (emit-simple op e 'x0)
     (emit op "asr x0, x0, ~a" (- IMM-SHIFT FIXNUM-SHIFT)))
    ((integer->char ,e)
     (emit-simple op e 'x0)
     (emit op "lsl x0, x0, ~a" (- IMM-SHIFT FIXNUM-SHIFT))
     (emit op "orr x0, x0, ~a" CHAR-TAG))
    ((,cmp ,e1 ,e2)
     (guard (memq cmp '(< <= eq? = >= >)))
     (emit-cmp op cmp e1 e2 si env))
    ((- ,e)
     (emit-simple op e 'x0)
     (emit op "neg x0, x0"))
    ((- ,e1 ,e2)
     (emit-simple op e2 'x1)
     (emit-simple op e1 'x0)
     (emit op "sub x0, x0, x1"))
    ((+ ,e1 ,e2)
     (emit-simple op e2 'x1)
     (emit-simple op e1 'x0)
     (emit op "add x0, x0, x1"))
    ((* ,e1 ,e2)
     (emit-simple op e2 'x1)
     (emit-simple op e1 'x0)
     (emit op "asr x1, x1, ~a" FIXNUM-SHIFT)
     (emit op "mul x0, x0, x1"))
    ((fixnum-width)
     (load-immediate op 'x0 (immediate-rep (- (ash WORDSIZE 3) 3))))
    ((fxabs ,e)
     (emit-simple op e 'x0)
     (emit op "cmp x0, 0")
     (emit op "cneg x0, x0, lt"))
    ((fxmax ,e1 ,e2)
     (emit-simple op e2 'x1)
     (emit-simple op e1 'x0)
     (emit op "cmp x0, x1")
     (emit op "csel x0, x0, x1, gt"))
    ((fxlength ,e1)
     (emit-prim op `(fxabs ,e1) si env)
     (emit op "orr x0, x0, ~a" FIXNUM-MASK)
     (emit op "clz x0, x0")
     (emit op "neg x0, x0")
     (emit op "add x0, x0, ~a" (- (ash WORDSIZE 3) 3))
     (emit op "lsl x0, x0, ~a" FIXNUM-SHIFT))
    ((div ,dividend ,divisor)
     #;((div (* t x) (* t y))
        => (div x y)
        => (tag (div x y)))
     (emit-simple op divisor 'x1)
     (emit-simple op dividend 'x0)
     (emit op "sdiv x0, x0, x1")
     (emit op "lsl x0, x0, ~a" FIXNUM-SHIFT))
    ((mod ,dividend ,divisor)
     ;;; TODO: don't know why this works?
     (emit-expr op divisor si env)
     (emit-simple op divisor 'x1)
     (emit-simple op dividend 'x0)
     (emit op "udiv x2, x0, x1")
     (emit op "msub x0, x2, x1, x0"))
    ((ashl ,e1 ,e2)
     (emit-simple op e2 'x1)
     (emit-simple op e1 'x0)
     (emit op "asr x1, x1, ~a" FIXNUM-SHIFT)
     (emit op "lsl x0, x0, x1"))
    ((ashr ,e1 ,e2)
     (emit-simple op e2 'x1)
     (emit-simple op e1 'x0)
     (emit op "asr x1, x1, ~a" FIXNUM-SHIFT)
     (emit op "asr x0, x0, ~a" FIXNUM-SHIFT)
     (emit op "asr x0, x0, x1")
     (emit op "lsl x0, x0, ~a" FIXNUM-SHIFT))
    ((bitwise-and ,e1 ,e2)
     (emit-simple op e2 'x1)
     (emit-simple op e1 'x0)
     (emit op "and x0, x0, x1"))
    ((bitwise-ior ,e1 ,e2)
     (emit-simple op e2 'x1)
     (emit-simple op e1 'x0)
     (emit op "orr x0, x0, x1"))
    ((null? ,e)
     (emit-simple op e 'x0)
     (emit op "and x0, x0, ~a" IMM-MASK)
     (emit-eax=? op NIL-TAG))
    ((pair? ,e)
     (emit-simple op e 'x0)
     (emit op "and x0, x0, ~a" PTR-MASK)
     (emit-eax=? op PAIR-TAG))
    ((cons ,e1 ,e2)
     (emit op "mov x0, ~a" AP-REG)
     (emit op "add ~a, ~a, ~a" AP-REG AP-REG (* 2 WORDSIZE))
     (emit-simple op e1 'x1)
     (emit-simple op e2 'x2)
     (emit op "str x1, [x0]")
     (emit op "str x2, [x0, ~a]" WORDSIZE)
     (emit op "orr x0, x0, ~a" PAIR-TAG))
    ((car ,e)
     (emit-simple op e 'x0)
     (emit op "add x0, x0, ~a" (- PAIR-TAG))
     (emit op "ldr x0, [x0]"))
    ((cdr ,e)
     (emit-simple op e 'x0)
     (emit op "add x0, x0, ~a" (- WORDSIZE PAIR-TAG))
     (emit op "ldr x0, [x0]"))
    ((set-car! ,e ,v)
     (emit-simple op v 'x1)
     (emit-simple op e 'x0)
     (emit op "add x0, x0, ~a" (- PAIR-TAG))
     (emit op "str x1, [x0]"))
    ((set-cdr! ,e ,v)
     (emit-simple op v 'x1)
     (emit-simple op e 'x0)
     (emit op "add x0, x0, ~a" (- WORDSIZE PAIR-TAG))
     (emit op "str x1, [x0]"))
    ((string? ,e)
     (emit-simple op e 'x0)
     (emit op "and x0, x0, ~a" PTR-MASK)
     (emit-eax=? op STR-TAG))
    ((make-string ,sz ,ch)
     (store-to-label op AP-REG 'free_ptr)
     (emit-foreign-call op 's_make_string (list sz ch) si env)
     (load-from-label op AP-REG 'free_ptr))
    ((string-length ,s)
     (emit-simple op s 'x0)
     (emit op "add x0, x0, ~a" (- STR-TAG))
     (emit op "ldr x0, [x0]"))
    ((string-set! ,s ,i ,v)
     (emit-simple op s 'x0)
     (emit-simple op i 'x1)
     (emit op "asr x1, x1, ~a" FIXNUM-SHIFT) ; remove fixnum mask
     (emit-simple op v 'x2)
     (emit op "asr x2, x2, ~a" IMM-SHIFT)    ; remove char mask
     (emit op "add x0, x0, ~a" (- WORDSIZE STR-TAG))
     (emit op "strb w2, [x0, x1]")
     (emit op "mov x0, 0"))
    ((string-ref ,s ,i)
     (emit-simple op s 'x0)
     (emit-simple op i 'x1)
     (emit op "asr x1, x1, ~a" FIXNUM-SHIFT) ; remove fixnum mask
     (emit op "add x0, x0, ~a" (- WORDSIZE STR-TAG))
     (emit op "ldrb w0, [x0, x1]")
     (emit op "lsl x0, x0, ~a" IMM-SHIFT)
     (emit op "orr x0, x0, ~a" CHAR-TAG))
    ((vector? ,e)
     (emit-simple op e 'x0)
     (emit op "and x0, x0, ~a" PTR-MASK)
     (emit-eax=? op VEC-TAG))
    ((vector . ,es)
     (emit-vector op es si env))
    ((vector-length ,e)
     (emit-simple op e 'x0)
     (emit op "add x0, x0, ~a" (- VEC-TAG))
     (emit op "ldr x0, [x0]"))
    ((make-vector ,sz ,obj)
     (store-to-label op AP-REG 'free_ptr)
     (emit-foreign-call op 's_make_vector (list sz obj) si env)
     (load-from-label op AP-REG 'free_ptr))
    ((vector-ref ,v ,i)
     (emit-simple op v 'x0)
     (emit-simple op i 'x1)
     (emit op "add x0, x0, ~a" (- WORDSIZE VEC-TAG))
     (emit op "ldr x0, [x0, x1]"))
    ((vector-set! ,v ,i ,e)
     (emit-simple op v 'x0)
     (emit-simple op i 'x1)
     (emit-simple op e 'x2)
     (emit op "add x0, x0, ~a" (- WORDSIZE VEC-TAG))
     (emit op "str x2, [x0, x1]")
     (emit op "mov x0, 0"))
    ((procedure? ,e)
     (emit-simple op e 'x0)
     (emit op "and x0, x0, ~a" PTR-MASK)
     (emit-eax=? op CLOS-TAG))
    ((symbol? ,e)
     (emit-simple op e 'x0)
     (emit op "and x0, x0, ~a" PTR-MASK)
     (emit-eax=? op SYM-TAG))
    ((%string->symbol ,e)
     (emit-simple op e 'x0)
     (emit op "add x0, x0, ~a" (- SYM-TAG STR-TAG)))
    ((%symbol->string ,e)
     (emit-simple op e 'x0)
     (emit op "add x0, x0, ~a" (- STR-TAG SYM-TAG)))
    (,() (error "emit-prim" "unmatch" e))))

(define (emit-walk-stack op e si env)
  ;;; e is atomic expression
  ;;; NOTE:
  ;;; The procedure assume esp is the frame pointer
  ;;; And top stack pointer implied by the si parameter
  ;;; gc_flip(word_t fx_size, word_t *esp, word_t *ebp)
  (define (emit-call-gc-flip)
    (store-to-label op AP-REG 'free_ptr)
    (emit op "mov x21, lr")
    (emit op "mov x22, sp")
    (emit op "mov x2, sp")
    (emit op "sub x1, x2, ~a" (- (abs si) WORDSIZE))
    (emit op "and sp, x1, -16")
    (emit op "bl gc_flip")
    (emit op "mov lr, x21")
    (emit op "mov sp, x22")
    (load-from-label op AP-REG 'free_ptr)
    ;;; NOTE: Restore back the closure pointer after GC
    (emit op "ldr ~a, [sp, ~a]" CLOS-REG (- WORDSIZE)))
  (cond
    ((not (integer? si))
     (error "emit-walk-stack" "unknown" si))
    ((eq? e -1)
     (emit-simple op e 'x0)
     (emit-call-gc-flip))
    (else
     (let ((cont (generate-label "cont")))
        (emit-simple op e 'x0)
        (emit op "mov x1, ~a" (immediate-rep GC-CTX-MIN-SIZE))
        (emit op "cmp x0, x1")
        (emit op "csel x0, x0, x1, lt")
        ; sz < fromspace_end - free_ptr
        (load-from-label op (vector-ref TEMPORARIES 0) 'fromspace_end)
        (emit op "sub ~a, ~a, ~a" (vector-ref TEMPORARIES 0) (vector-ref TEMPORARIES 0) AP-REG)
        (emit op "lsl ~a, ~a, ~a" (vector-ref TEMPORARIES 0) (vector-ref TEMPORARIES 0) FIXNUM-SHIFT)
        (emit op "cmp x0, ~a" (vector-ref TEMPORARIES 0))
        (emit op "blt ~a" cont)
        (emit-call-gc-flip)
        (emit op "~a: " cont)))))

(define (emit-tail-call op maybe-decl fn args si env)
  (let* ((argc (length (cons fn args)))
         (calc-offset (lambda (i) (- si (* WORDSIZE i)))))
    (for-each
      (lambda (offset arg)
        (emit-simple op arg 'x0)
        (emit-store op 'x0 'sp offset (vector-ref TEMPORARIES 0)))
      (map calc-offset (iota argc))
      (cons fn args))
    ;;; copying the memory
    (for-each
      (lambda (i)
        (emit-load op 'x0 'sp (calc-offset i) (vector-ref TEMPORARIES 0))
        (emit-store op 'x0 'sp (* (- WORDSIZE) (+ i 1)) (vector-ref TEMPORARIES 0)))
      (iota argc))
    (emit op "mov ~a, ~a" (vector-ref TEMPORARIES 0) argc)
    (match maybe-decl
      ((label ,lbl)
       (emit op "b ~a" lbl))
      (#f
       (emit op "ldr x0, [sp, ~a]" (- WORDSIZE))
       (emit op "add x0, x0, ~a" (- CLOS-TAG))
       (emit op "ldr x0, [x0]")
       (emit op "br x0"))
      (,() (error "emit-tail-call" "unmatch" maybe-decl)))))

(define (emit-call op maybe-decl fn args si env)
  (let* ((argc (length (cons fn args)))
         (start-si (- si (* 2 WORDSIZE)))
         (calc-offset (lambda (i) (- start-si (* WORDSIZE i)))))
    (for-each
      (lambda (offset arg)
        (emit-simple op arg 'x0)
        (emit-store op 'x0 'sp offset (vector-ref TEMPORARIES 0)))
      (map calc-offset (iota argc))
      (cons fn args))
    (emit op "mov ~a, ~a" (vector-ref TEMPORARIES 0) argc)
    ;;; placeholder for return address
    ;;; this store the frame pointer
    (emit op "mov fp, sp")
    (emit op "sub sp, sp, ~a" (+ (abs si) WORDSIZE))
    (emit op "str lr, [sp, ~a]" WORDSIZE)
    (emit op "str fp, [sp]")
    (match maybe-decl
      ((label ,lbl)
       (emit op "bl ~a" lbl))
      (#f
       (emit op "ldr x0, [sp, ~a]" (- WORDSIZE))
       (emit op "add x0, x0, ~a" (- CLOS-TAG))
       (emit op "ldr x0, [x0]")
       (emit op "blr x0"))
      (,() (error "emit-call" "unmatch" maybe-decl)))
    (emit op "ldr lr, [sp, ~a]" WORDSIZE)
    (emit op "add sp, sp, ~a" (+ (abs si) WORDSIZE))
    (emit op "ldr ~a, [sp, ~a]" CLOS-REG (- WORDSIZE))))

(define (emit-foreign-call op fn args si env)
  (let* ((argc (length args))
         (end-si si))
    (let loop ((args args) (regs REGISTERS))
      (if (pair? args)
          (begin
            (emit-simple op (car args) (car regs))
            (loop (cdr args) (cdr regs)))))
    (emit op "mov x21, lr")
    (emit op "sub sp, sp, ~a" (- (abs end-si) WORDSIZE))
    (emit op "bl ~a" fn)
    (emit op "add sp, sp, ~a" (- (abs end-si) WORDSIZE))
    (emit op "mov lr, x21")))

(define (emit-tail-apply op fn es si env)
  (emit-simple op fn 'x0)
  (emit-simple op es 'x1)
  (emit op "str x0, [sp, ~a]" (- WORDSIZE))
  (emit op "str x1, [sp, ~a]" (- (* 2 WORDSIZE)))
  (emit op "b L_apply"))

(define (emit-apply op fn es si env)
  (emit-simple op fn 'x0)
  (emit-simple op es 'x1)
  (emit op "mov fp, sp")
  (emit op "sub sp, sp, ~a" (+ (abs si) WORDSIZE))
  (emit-store op 'lr 'sp WORDSIZE (vector-ref TEMPORARIES 0))
  (emit-store op 'fp 'sp 0 (vector-ref TEMPORARIES 0))
  (emit op "stp x1, x0, [sp, ~a]" (* -2 WORDSIZE))
  (emit op "bl L_apply")
  (emit op "ldr lr, [sp, ~a]" WORDSIZE)
  (emit op "add sp, sp, ~a" (+ (abs si) WORDSIZE))
  (emit op "ldr ~a, [sp, ~a]" CLOS-REG (- WORDSIZE)))

(define (emit-L-apply op)
  (let ((loop (generate-label "unstack"))
        (end (generate-label "call")))
    (emit op ".p2align 3")
    (emit op "L_apply: ")
    ;;; (apply fn es)
    ;;; x0 : fn
    ;;; x1 : es
    ;;; x2 : moving stack pointer
    ;;; t0 : argc
    (emit op "sub x2, sp, ~a" (* 2 WORDSIZE))
    (emit op "mov ~a, 1" (vector-ref TEMPORARIES 0))
    (emit op "~a: " loop)
    (emit op "cmp x1, ~a" NIL-TAG)
    (emit op "beq ~a" end)
    (emit op "add x1, x1, ~a" (- PAIR-TAG))
    (emit op "ldp ~a, x1, [x1]" (vector-ref TEMPORARIES 1))
    (emit op "str ~a, [x2]" (vector-ref TEMPORARIES 1))
    (emit op "add ~a, ~a, 1" (vector-ref TEMPORARIES 0) (vector-ref TEMPORARIES 0))
    (emit op "sub x2, x2, ~a" WORDSIZE)
    (emit op "b ~a" loop)
    (emit op "~a: " end)
    (emit op "add x0, x0, ~a" (- CLOS-TAG))
    (emit op "ldr x0, [x0]")
    (emit op "br x0")))

(define (emit-construct-vararg op argc si)
  #;(
      [z 1]
      ()  0
      (1) 1

      [(x y . z) 3]
      (0)           1   err
      (0 1)         2   (0 1 ())
      (0 1 2)       3   (0 1 (2))
      (0 1 2 3)     4   (0 1 (2 3))
      (0 1 2 3 4)   5   (0 1 (2 3 4))
      
      example
      inp         cons    argc  sz
      (0 1 2 3 4) ()      5     3
      (0 1 2 3)   (4)     4     3
      (0 1 2)     (3 4)   3     3
      (0 1)       (2 3 4) 2     3
  )
  (emit op "ldr ~a, =free_ptr" (vector-ref TEMPORARIES 1))
  (emit op "str ~a, [~a]" AP-REG (vector-ref TEMPORARIES 1))
  (emit op "mov x21, sp")
  (emit op "mov x22, lr")
  (emit op "mov x3, sp")
  (emit op "lsl x1, ~a, ~a" 
           (vector-ref TEMPORARIES 0)
           FIXNUM-SHIFT)
  (emit op "sub x2, x3, x1")
  (emit op "mov x0, ~a" argc)
  (emit op "and ~a, x2, -16" (vector-ref TEMPORARIES 0))
  (emit op "mov sp, ~a" (vector-ref TEMPORARIES 0))
  (emit op "bl construct_vararg")
  (emit op "mov sp, x21")
  (emit op "mov lr, x22")
  (emit-store op 'x0 'sp (* (- WORDSIZE) argc) (vector-ref TEMPORARIES 0))
  (load-from-label op AP-REG 'free_ptr))

(define (emit-procedure op fn params variadic? fvs body)
  (let* ((argc (length params))
         (env (make-env))
         (si (* (- WORDSIZE) (+ argc 1))))
    (emit op ".p2align 3")
    (emit op ".globl ~a" fn)
    (emit op ".type ~a, @function" fn)
    (emit op "~a: " fn)
    (if (not variadic?)
        (let ((end (generate-label 'conseq)))
          (emit op "cmp ~a, ~a" (vector-ref TEMPORARIES 0) argc)
          (emit op "beq ~a" end)
          (emit-foreign-call op 's_proc_arg_err '() si env)
          (emit op "~a: " end))
        (emit-construct-vararg op argc si))
    ;;; NOTE: first argument is always the closure
    (emit op "ldr ~a, [sp, ~a]" CLOS-REG (- WORDSIZE))
    (match body
      (((alloca ,i) . ,body)
       (guard (and (integer? i) (<= (sub1 argc) i)))
       (for-each
          (lambda (i)
            (emit-store op 'xzr 'sp (* (- WORDSIZE) (+ i 2)) (vector-ref TEMPORARIES 0)))
          (filter (lambda (i) (<= argc i))
                  (iota (+ (align-to-multiple 2 i) 1))))
       (emit-seq op body (* (- WORDSIZE) (+ (align-to-multiple 2 i) 3)) env))
      (,() (error "emit-procedure" "unknown body" body)))
    (emit op "ret")))

(define (emit-variadic-procedure op fn fvs clauses)
  (let* ((env (make-env)))
    (emit op ".p2align 3")
    (emit op ".globl ~a" fn)
    (emit op ".type ~a, @function" fn)
    (emit op "~a: " fn)
    (emit op "ldr ~a, [sp, ~a]" CLOS-REG (- WORDSIZE))
    (for-each
      (lambda (clause)
        (match clause
          ((closure ,fn ,fvs ,variadic? ,argc)
           (let ((next (generate-label "case_lambda_altern")))
            (cond
              (variadic?
               (emit op "mov ~a, ~a" (vector-ref TEMPORARIES 1) (sub1 argc))
               (emit op "cmp ~a, ~a" (vector-ref TEMPORARIES 0) (vector-ref TEMPORARIES 1))
               (emit op "blt ~a" next))
              (else
               (emit op "mov ~a, ~a" (vector-ref TEMPORARIES 1) argc)
               (emit op "cmp ~a, ~a" (vector-ref TEMPORARIES 0) (vector-ref TEMPORARIES 1))
               (emit op "bne ~a" next)))
            (emit op "mov x21, ~a" (vector-ref TEMPORARIES 0))
            (emit-closure op fn fvs #f env)
            (emit op "str x0, [sp, ~a]" (- WORDSIZE))
            (emit op "mov ~a, x21" (vector-ref TEMPORARIES 0))
            (emit op "b ~a" fn)
            (emit op "~a: " next)))
          (,() (error "emit-variadic-procedure" "unknown clause" clause))))
      clauses)
    (emit-foreign-call op 's_proc_arg_err '() (- (* 2 WORDSIZE)) env)))

(define (emit-closure op fn fvs si env)
  (define fvs-count (length fvs))
  (emit op "mov x0, ~a" AP-REG)
  (emit op "add ~a, ~a, ~a"
           AP-REG AP-REG (align-to-multiple 8 (* WORDSIZE (+ 2 fvs-count))))
  (emit op "ldr ~a, =~a" (vector-ref TEMPORARIES 0) fn)
  (emit op "str ~a, [x0]" (vector-ref TEMPORARIES 0))
  (load-immediate op (vector-ref TEMPORARIES 0) (immediate-rep fvs-count))
  (emit op "str ~a, [x0, ~a]" (vector-ref TEMPORARIES 0) WORDSIZE)
  (for-each
    (lambda (fv i)
      (emit-simple op fv 'x1)
      (emit-store op 'x1 'x0 (* WORDSIZE (+ 2 i)) (vector-ref TEMPORARIES 0)))
    fvs
    (iota fvs-count))
  (emit op "orr x0, x0, ~a" CLOS-TAG))

(define (emit-seq op es si env)
  (for-each
    (lambda (e) (emit-expr op e si env))
    es))

(define (emit-expr op e si env)
  (match e
    (,()
     (guard (immediate? e))
     (emit-simple op e 'x0))
    (,()
     (guard (string? e))
     (emit-str-lit op e si))
    ((local-set! ,i ,e)
     (guard (integer? i))
     (emit-expr op e si env)
     (emit-store op 'x0 'sp (* (- WORDSIZE) (+ i 2)) 'x1))
    ((local-ref ,i)
     (guard (integer? i))
     (emit-simple op e 'x0))
    ((quote ())
     (emit-simple op e 'x0))
    ((collect)
     (emit-walk-stack op -1 si env))
    ((collect ,sz)
     (emit-walk-stack op sz si env))
    ((global ,lbl)
     (load-from-label op 'x0 lbl))
    ((label ,lbl)
     (load-from-label op 'x0 lbl))
    ((closure-ref ,() ,i)
     (guard (integer? i))
     (emit op "add x0, ~a, ~a" CLOS-REG (- (* WORDSIZE (+ i 2)) CLOS-TAG))
     (emit op "ldr x0, [x0]"))
    ((set-label! ,lbl ,e)
     (emit-expr op e si env)
     (store-to-label op 'x0 lbl))
    ((begin . ,es)
     (emit-seq op es si env))
    ((if ,pred ,conseq ,altern)
     (emit-if op pred conseq altern si env))
    ((closure ,fn ,fvs)
     (emit-closure op fn fvs si env))
    ((call ,tail? (prim apply) ,fn ,es)
     ((if tail? emit-tail-apply emit-apply) op fn es si env))
    ((call ,() (prim ,pr) . ,es)
     (emit-prim op (cons pr es) si env))
    ((call ,tail? ,maybe-decl ,fn . ,es)
     ((if tail? emit-tail-call emit-call) op maybe-decl fn es si env))
    ((foreign-call! ,fn . ,es)
     (store-to-label op AP-REG 'free_ptr)
     (emit-foreign-call op fn es si env)
     (load-from-label op AP-REG 'free_ptr))
    ((foreign-call ,fn . ,es)
     (emit-foreign-call op fn es si env))
    (,() (error "emit-expr" "unmatch" e))))

(define (emit-code op entry-name prog)
  (match prog
    ((program (labels . ,labels)
              (data . ,data)
              (unbounds . ,unbounds)
              ((alloca ,i) . ,body))
     ;;; NOTE:
     ;;; referenced operand position primitives are not externed here
     ;;; but dont know what are the risk
     (emit op ".globl ~a" entry-name)
     (emit op ".extern L_apply")
     (for-each (lambda (g) (emit op ".extern ~a" g)) (set-union data unbounds))
     (emit op ".section .text")
     (for-each
       (lambda (label)
         (match label
           ((,name (code ,params ,variadic? ,fvs ,e))
            (emit-procedure op name params variadic? fvs e))
           ((,name (case-code ,fvs . ,clauses))
            (emit-variadic-procedure op name fvs clauses))
           (,() (error "emit-code" "unmatch" label))))
       labels)
     (emit op "~a:" entry-name)
     (emit op "mov fp, sp")
     (emit op "str xzr, [sp, ~a]" (- WORDSIZE))
     (for-each
       (lambda (i)
        (emit-store op 'xzr 'sp (* (- WORDSIZE) (+ i 2)) (vector-ref TEMPORARIES 0)))
       (iota (+ 1 (align-to-multiple 2 i))))
     (emit-seq op body (* (- WORDSIZE) (+ (align-to-multiple 2 i) 3)) (make-env))
     (emit op "mov x0, 0")
     (emit op "ret"))
    (,() (error "emit-code" "unmatch" prog))))

(define (program->data prog)
  (match prog
    ((program (labels . ,()) (data . ,data) (unbounds . ,()) ,()) data)
    (,() (error "program->data" "unmatch" prog))))

(define (emit-obj input-path output-path k)
  (define tmp-filename (mk-tmpname (path-fileroot input-path) "s"))
  (let* ((prog (preprocess (cons 'begin (read-sexps-from-path input-path))))
         (entry-name (format "~a.main" (string->id-string (path-fileroot input-path))))
         (data (program->data prog))
         (op (open-output-file tmp-filename)))
    (emit-code op entry-name prog)
    (close-output-port op)
    (system* "~a ~a -c ~a -o ~a"
             CC CC-ARGS
             tmp-filename output-path)
    (system* "rm -f ~a" tmp-filename)
    (k entry-name data)))

(define (read-meta obj-file)
  (let* ((filename (mk-tmpname "read-meta" "txt"))
          (_ (system* "~a --dump-section .main_entry=~a ~a"
                      OBJCOPY
                      filename obj-file))
          (inp (open-input-file filename))
          (meta (read inp)))
    (close-port inp)
    (system* "rm -f ~a" filename)
    meta))

(define (map3-k f xs k)
  (let recur ((xs xs) (k k))
    (if (not (pair? xs))
        (k '() '() '())
        (f (car xs)
          (lambda (x y z)
            (recur (cdr xs)
              (lambda (xs ys zs)
                (k (cons x xs) (cons y ys) (cons z zs)))))))))

(define (emit-objs input-paths k)
  (map3-k
    (lambda (i k)
      (if (equal? (path-extension i) "o")
          (let ((out (mk-tmpname i "o")))
            (system* "cp ~a ~a" i out)
            (k out (read-meta out) (lambda () (system* "rm -f ~a" out))))
          (let ((out (mk-tmpname i "o")))
            (emit-obj i out
              (lambda (entry-name data) (k out (list (list entry-name) data) (lambda () (system* "rm -f ~a" out))))))))
    input-paths
    k))

(define (combine-objs output-path objs metas)
  (let* ((tmp-filename (mk-tmpname (path-fileroot output-path) ".linker"))
         (op (open-output-file tmp-filename)))
    (define entries (apply append (map car metas)))
    (define globals (apply set-union (map cadr metas)))
    (write (list entries globals) op)
    (close-output-port op)
    (system* "~a ~a -r -o ~a ~a"
             CC CC-ARGS
             output-path
             (apply string-append
                    (map (lambda (s) (string-append " \"" s "\" ")) objs)))
    (system* "~a --remove-section=.main_entry --add-section .main_entry=~a ~a"
             OBJCOPY
             tmp-filename
             output-path)
    (system* "rm -f ~a" tmp-filename)))

(define (emit-main output-path objs metas)
  (define (make-prim-call pr . es)
    `(call #f (prim ,pr) . ,es))
  (define (make-box-init)
    (make-prim-call 'cons 0 '(quote ())))
  (define entries (apply append (map car metas)))
  (define globals (apply set-union (map cadr metas)))
  (define tmp-filename (mk-tmpname (string-append (path-fileroot output-path) "-exec") "s"))
  (let* ((op (open-output-file tmp-filename)))
    (emit op ".globl main")
    (emit op ".globl L_apply")
    (for-each (lambda (g) (emit op ".globl ~a" g)) globals)

    (emit op ".section .data")
    (emit op ".globl global_table")
    (emit op "global_table:")
    (for-each
      (lambda (g) (emit op ".~abyte ~a" WORDSIZE g))
      globals)
    (emit op ".~abyte 0" WORDSIZE)
    (for-each
      (lambda (g)
      (match g
        (,()
         (guard (symbol? g))
         (emit op ".p2align 3")
         (emit op "~a: .~abyte 0" g WORDSIZE))
        (,() (error "linking-to-exe" "unmatch" g))))
      globals)
    (emit op ".section .text")
    (emit-L-apply op)
    (emit op "main:")
    (emit op "sub sp, sp, ~a" (* 2 WORDSIZE))
    (emit op "stp fp, lr, [sp]")
    (emit op "mov fp, sp")
    (store-to-label op 'fp "BOT_EBP")
    (store-to-label op 'x1 'ARGV)
    (store-to-label op 'x0 'ARGC)
    (emit op "bl init_heap")
    (emit op "ldp fp, lr, [sp]")
    (load-from-label op AP-REG "free_ptr")
    (emit op "# globals")
    (for-each
      (lambda (g)
        (emit-expr op `(set-label! ,g ,(make-box-init)) (- WORDSIZE) #f))
      globals)
    (emit op "# end of globals")
    (for-each (lambda (entry) (emit op "bl ~a" entry)) entries)
    (emit op "ldp fp, lr, [sp]")
    (emit op "add sp, sp, ~a" (* 2 WORDSIZE))
    (emit op "mov x0, 0")
    (emit op "ret")
    (close-output-port op))
  (system* "~a ~a ~a ~a -r -o ~a"
           CC CC-ARGS
           tmp-filename
           (apply string-append
                  (map (lambda (s) (string-append " \"" s "\" ")) objs))
            output-path)
  (system* "rm -f ~a" tmp-filename))

(match (cdr (command-line))
  (("-o" ,output-path . ,input-paths)
   (guard (equal? (path-extension output-path) "out"))
   (emit-objs input-paths
    (lambda (objs metas frees)
      (let ((tmp-filename (mk-tmpname (path-fileroot output-path) "o")))
        (emit-main tmp-filename objs metas)
        (system* "~a ~a runtime.o ~a -o ~a"
                 CC CC-ARGS
                 tmp-filename output-path)
        (system* "rm -f ~a" tmp-filename))
      (map (lambda (f) (f)) frees))))
  (("-o" ,output-path . ,input-paths)
   (guard (equal? (path-extension output-path) "o"))
   (emit-objs input-paths
    (lambda (objs metas frees)
      (combine-objs output-path objs metas)
      (map (lambda (f) (f)) frees))))
  (("--emit-main" ,output-path . ,input-paths)
   (emit-objs input-paths
    (lambda (objs metas frees)
      (emit-main output-path objs metas)
      (map (lambda (f) (f)) frees))))
  (("--bin" ,output-path ,runtime ,main)
   (system* "~a ~a ~a ~a -o ~a" CC CC-ARGS runtime main output-path))
  (("--make-prim-lib" ,output-path)
   (write-primitive-lib output-path))
  ((,input-path . ,input-paths)
   (emit-objs (cons input-path input-paths)
    (lambda (objs metas frees)
      (let* ((tmpname (mk-tmpname "tmp" ""))
             (final (string-append tmpname ".o"))
             (out (string-append tmpname ".out")))
        (emit-main final objs metas)
        (system* "~a ~a runtime.o ~a -o ~a"
                 CC CC-ARGS
                 final out)
        (system* out)
        (system* "rm -f ~a ~a" final out))
      (map (lambda (f) (f)) frees))))
  (,cmd-ln (error (car (command-line)) "unmatch" cmd-ln)))
)