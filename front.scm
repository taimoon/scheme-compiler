(import
  (only (match) match)
  (only (set) make-set set-union set-diff)
  (only (utils)
    make-env extend-env maybe-apply-env apply-env
    read-sexps-from-path align-to-multiple
    symbol->id-symbol string->id-string generate-label
    system*))
(include "match-defmacro.scm")

(define (improper-list? xs)
  (cond
    ((null? xs) #f)
    ((pair? xs) (improper-list? (cdr xs)))
    (else #t)))

(define (improper->proper xs)
  (cond
    ((null? xs) xs)
    ((symbol? xs) (list xs))
    ((pair? xs) (cons (car xs) (improper->proper (cdr xs))))
    (else (error "improper->proper" "unknown object" xs))))

;;; uniquify
(define keywords
  '(begin let if
    let*
    cond not and or
    lambda letrec case-lambda
    set! foreign-call apply prim-call
    quote quasiquote unquote unquote-splicing
    match import include))

(define primitives
  '(
    (add1 n)
    (sub1 n)
    (+ n m)
    (- n m)
    (* n m)
    (div n m)
    (mod n m)
    (< n m)
    (<= n m)
    (= n m)
    (>= n m)
    (> n m)
    (ashl n m)
    (ashr n m)
    (bitwise-and n m)
    (bitwise-ior n m)
    (eq? x y)
    (integer? x)
    (char? x)
    (char->integer c)
    (integer->char i)
    (procedure? x)
    (boolean? x)
    (null? x)
    (pair? x)
    (cons x y)
    (car p)
    (cdr p)
    (string? x)
    (make-string n)
    (string-length s)
    (string-ref s i)
    (string-set! s i c)
    (vector? x)
    vector
    (make-vector v)
    (vector-length v)
    (vector-ref v i)
    (vector-set! v i x)
    (symbol? x)
    %string->symbol %symbol->string
    %walk-stack %raw-print))

(define (init-uenv)
  (define (make-prim p)
    `(prim ,p))
  (extend-env
    keywords
    (map (lambda _ 'keyword) keywords)
    (let ((primitives (map (lambda (p) (if (pair? p) (car p) p)) primitives)))
      (extend-env primitives (map make-prim primitives) (make-env)))))

(define (write-primitive-lib output-path)
  (system* "rm -f ~a" output-path)
  (let ((out (open-output-file output-path)))
    (for-each
      (lambda (p)
        (if (symbol? p)
            #t
            (begin
              (write
                `(define ,p
                  (prim-call . ,p))
                out)
              (newline out))))
      primitives)))

(define (keyword? kw env)
  (and (symbol? kw)
       (let ((res (maybe-apply-env kw env)))
        (and (pair? res)
             (eq? (cadr res) 'keyword)))))

;; sugars
(define (let*->let e)
  (if (null? (cadr e))
      (cons 'begin (cddr e))
      (let*->let-aux (cadr e) (cddr e))))

(define (let*->let-aux bindings body)
  (if (null? (cdr bindings))
      (list* 'let (list (car bindings)) body)
      (list 'let (list (car bindings)) (let*->let-aux (cdr bindings) body))))

(define (cond->ifs e)
  (if (or (not (pair? e)) (null? (cdr e)))
      (error "cond" "syntax error" e)
      (cond-clauses->ifs (cdr e))))

(define (cond-clauses->ifs clauses)
  (if (not (pair? clauses))
      #f
      (let ((pred (caar clauses))
            (conseq (cons 'begin (cdar clauses)))
            (clauses (cdr clauses)))
        (if (eq? pred 'else)
            (if (pair? clauses)
                (error "cond-clauses->ifs" "misplaced else" clauses)
                conseq)
            (list 'if pred
                      conseq
                      (cond-clauses->ifs clauses))))))

(define (not->if e)
  (list 'if e #f #t))

(define (or->ifs es)
  (if (pair? es)
      (list 'if (car es) #t (or->ifs (cdr es)))
      #f))

(define (and->ifs es)
  (if (pair? es)
      (list 'if (car es) (and->ifs (cdr es)) #f)
      #t))

(define (quote->cons q)
  (cond
    ((null? q) ''())
    ((pair? q)
     `(cons ,(quote->cons (car q))
            ,(quote->cons (cdr q))))
    ((symbol? q) `(quote ,q))
    (else q)))

(define (expand-qq form)
  (cond 
    ((not (pair? form)) (list 'quote form))
    ((eq? 'quasiquote (car form)) (expand-qq (cadr form)))
    ((eq? 'unquote (car form)) (cadr form))
    (else (qq-list form))))

(define (tail-unquote? form)
  (and
    (pair? form)
    (pair? (cdr form))
    (null? (cddr form))
    (eq? (car form) 'unquote)))

(define (tail-unquote a)
  (cadr a))

(define (qq-list form)
  (cond 
    ((null? form) ''())
    ((not (pair? form))
     (list 'list (expand-qq form)))
    ((tail-unquote? form)
     (tail-unquote form))
    ((and (pair? (car form))
          (eq? 'unquote-splicing (caar form)))
      (list 'append (cadar form) (qq-list (cdr form))))
    (else (list 'append (list 'list (expand-qq (car form))) (qq-list (cdr form))))))

(define (linearize-seq es)
  (define (linearize e)
    (if (and (pair? e) (eq? (car es) 'begin))
        (map linearize-seq (cdr es))
        (list e)))
  (fold-right (lambda (e acm) (append (linearize e) acm)) '() es))

(define (linearize-begin es)
  (let ((es (linearize-seq es)))
    (if (= (length es) 1)
        (car es)
        (cons 'begin es))))

(define (uniquify-each es env)
  (if (pair? es)
      (cons (uniquify (car es) env)
            (uniquify-each (cdr es) env))
      '()))

(define (uniquify-seq es env)
  (collect-definition (linearize-seq es)
    (lambda (defns es) 
      (define (defn->binding d)
        (match d
          ((define (,fn . ,params) . ,body)
           `(,fn (lambda ,params . ,body)))
          ((define ,x ,e)
           `(,x ,e))
          (,() (error "defn->binding" "unmatch" d))))
      (cond
        ((pair? defns)
         (list (uniquify `(letrec ,(map defn->binding defns) . ,es) env)))
        (else (uniquify-each es env))))))

(define (uniquify e env)
  (match e
    (,()
     (guard (symbol? e))
     (let ((res (maybe-apply-env e env)))
      (if res
          (cadr res)
          `(global ,(symbol->id-symbol e) ,e))))
    (,()
     (guard (vector? e))
     (uniquify `(vector . ,(vector->list e)) env))
    (,()
     (guard (not (pair? e)))
     e)
    ((,e . ,es)
     (guard (not (keyword? e env)))
     (match (uniquify e env)
      ((prim add1)
       `(prim-call + ,(uniquify (car es) env) 1))
      ((prim sub1)
       `(prim-call - ,(uniquify (car es) env) 1))
      ((prim %raw-print)
       `(foreign-call raw_print ,(uniquify (car es) env)))
      ((prim ,p)
       `(prim-call ,p . ,(uniquify-each es env)))
      (,op
       `(call ,op . ,(uniquify-each es env)))))
    ((prim-call ,p . ,es)
     (match p
      (add1
       `(prim-call + ,(uniquify (car es) env) 1))
      (sub1
       `(prim-call - ,(uniquify (car es) env) 1))
      (,() `(prim-call ,p . ,(uniquify-each es env)))))
    ((quote ,x)
     (guard (symbol? x))
     e)
    ('() e)
    ((quote ,e)
     (uniquify (quote->cons e) env))
    ((quasiquote ,x)
     (uniquify (expand-qq x) env))
    ((begin . ,es)
     (let ((e* (uniquify-seq es env)))
      (if (and (pair? e*) (not (pair? (cdr e*))))
          (car e*)
          (cons 'begin e*))))
    ((if ,pred ,conseq)
     (uniquify `(if ,pred ,conseq #f) env))
    ((if ,pred ,conseq ,altern)
     `(if ,(uniquify pred env) 
          ,(uniquify conseq env) 
          ,(uniquify altern env)))
    ((not ,e)
     (uniquify (not->if e) env))
    ((and . ,es)
     (uniquify (and->ifs es) env))
    ((or . ,es)
     (uniquify (or->ifs es) env))
    ((cond . ,clauses)
     (uniquify (cond-clauses->ifs clauses) env))
    ((let () . ,es)
     (uniquify `(begin . ,es) env))
    ((let ,fn ,inits . ,es)
     (guard (symbol? fn))
     (let ((params (map car inits))
           (args (map cadr inits)))
      (uniquify
        `(letrec ((,fn (lambda ,params . ,es)))
          (,fn . ,args))
        env)))
    ((let ,bs . ,es)
     (let* ((xs (map car bs))
            (xs* (map generate-label (map car bs)))
            (inner-env (extend-env xs (map (lambda (x) `(var ,x)) xs*) env))
            (inits (map (lambda (b) (uniquify (cadr b) env)) bs)))
      `(let ,(map list xs* inits) . ,(uniquify-seq es inner-env))))
    ((let* ,bs . ,es)
     (uniquify (let*->let-aux bs es) env))
    ((letrec () . ,es)
     (uniquify `(begin . ,es) env))
    ((letrec ,bs . ,es)
     (define (simplify-letrec bs es)
      (let* ((vars (map car bs))
             (inits (map cadr bs)))
        ;;; unfaithful implementation
        `(let ,(map (lambda (v) (list v 0)) vars)
            ,@(map (lambda (v init) `(set! ,v ,init)) vars inits)
            ,@es)))
     (uniquify (simplify-letrec bs es) env))
    ((lambda ,params . ,body)
     (let* ((variadic? (improper-list? params))
            (params (improper->proper params))
            (params* (map generate-label params))
            (env (extend-env params (map (lambda (x) `(var ,x)) params*) env)))
      `(lambda ,params* ,variadic? . ,(uniquify-seq body env))))
    ((case-lambda . ,clauses)
     `(case-lambda
        . ,(uniquify-each
              (map (lambda (c) (cons 'lambda c)) clauses)
              env)))
    ((set! ,x ,e)
     (match (maybe-apply-env x env)
      ((,() (var ,x))
       `(set! ,x ,(uniquify e env)))
      (#f
       ;;; WORKAROUND
       `(prim-call set-car!
          (global-ref ,(symbol->id-symbol x) ,x) ,(uniquify e env)))
      (,res (error "uniquify" "unmatch" res))))
    ((foreign-call ,fn . ,es)
     `(foreign-call ,fn . ,(uniquify-each es env)))
    ((apply ,f ,es)
     `(apply ,(uniquify f env) ,(uniquify es env)))
    ((match . ,())
     (uniquify (compile-match e) env))
    ((import . ,()) ''())
    ((include . ,()) ''())
    (,() (error "uniquify" "unmatch" e))))

(define (definition-variable defn)
  (match defn
    ((define (,fn . ,()) . ,()) fn)
    ((define ,fn ,()) fn)
    (,() (error "definition-variable" "unmatch" defn))))

(define (definition-value defn)
  (match defn
    ((define (,() . ,params) . ,body)
     `(lambda ,params  . ,body))
    ((define ,() ,e)
     e)
    (,() (error "definition-value" "unmatch" defn))))

(define (collect-definition es cont)
  (if (pair? es)
      (match (car es)
        ((define . ,())
          (collect-definition (cdr es)
           (lambda (defns es*)
             (cont (cons (car es) defns) es*))))
        (,e (collect-definition (cdr es)
              (lambda (defns es) (cont defns (cons e es))))))
      (cont '() '())))

(define (uniquify-program prog)
  (match prog
    ((begin . ,es)
     (collect-definition es
      (lambda (defns es)
        (let* ((vars (map definition-variable defns))
               (vals (map definition-value defns))
               (vars* (map symbol->id-symbol vars))
               (env (extend-env vars (map (lambda (v) `(var ,v)) vars*) (init-uenv)))
               (vals* (uniquify-each vals env))
               (es (uniquify-each es env))
               (unbounds (collect-global-each es)))
          `(program (labels) (data . ,vars*) (unbounds . ,unbounds)
            ,@(map (lambda (v w) `(set! ,v ,w)) vars* vals*)
            ,@es)))))
    (,() (error "uniquify-program" "unmatch" prog))))

;;; collect-global
(define (collect-global-each es)
  (fold-left set-union (make-set) (map collect-global es)))

(define (collect-global e)
  (match e
    (,()
     (guard (not (pair? e)))
     (make-set))
    ('() (make-set))
    ((var ,()) (make-set))
    ((prim ,()) (make-set))
    ((quote ,()) (make-set))
    ((let ,bs . ,es)
     (set-union (collect-global-each (map cadr bs)) (collect-global-each es)))
    ((foreign-call ,fn . ,es)
     (set-union (make-set fn) (collect-global-each es)))
    ((prim-call ,() . ,es)
     (collect-global-each es))
    ((,form . ,es)
     (guard (member form '(if begin call apply case-lambda)))
     (collect-global-each es))
    ((lambda ,params . ,es)
     (collect-global-each es))
    ((set! ,x ,e)
     (collect-global e))
    ((global ,lbl ,ori)
     (make-set lbl))
    ((global-ref ,lbl ,ori)
     (make-set lbl))
    (,() (error "collect-global" "unmatch" e))))

;;; collect-symbol
(define (collect-symbol-each es)
  (fold-left set-union (make-set) (map collect-symbol es)))

(define (collect-symbol e)
  (match e
    (,()
     (guard (not (pair? e)))
     (make-set))
    ((global ,() ,())
     (make-set))
    ((global-ref ,() ,())
     (make-set))
    ((var ,())
     (make-set))
    ((quote ,x)
     (guard (symbol? x))
     (make-set x))
    ((quote ())
     (make-set))
    ((prim ,())
     (make-set))
    ((,form . ,es)
     (guard (memq form '(if begin call apply case-lambda)))
     (collect-symbol-each es))
    ((,form ,() . ,es)
     (guard (memq form '(prim-call foreign-call)))
     (collect-symbol-each es))
    ((set! ,() ,e)
     (collect-symbol e))
    ((lambda ,() ,() . ,es)
     (collect-symbol-each es))
    ((let ,bs . ,es)
     (set-union (collect-symbol-each es)
                (collect-symbol-each (map cadr bs))))
    (,() (error "collect-symbol" "unmatch" e))))

(define (lift-symbol-each es env)
  (map (lambda (e) (lift-symbol e env)) es))

(define (lift-symbol e env)
  (match e
    (,()
     (guard (not (pair? e)))
     e)
    ((var ,())
     e)
    ((quote ())
     e)
    ((quote ,x)
     (guard (symbol? x))
     (apply-env x env))
    ((prim ,())
     e)
    ((global ,() ,()) e)
    ((global-ref ,() ,()) e)
    ((,form . ,es)
     (guard (memq form '(if begin call apply case-lambda)))
     `(,form . ,(lift-symbol-each es env)))
    ((,form ,fn . ,es)
     (guard (memq form '(prim-call foreign-call)))
     `(,form ,fn . ,(lift-symbol-each es env)))
    ((set! ,x ,e)
     `(set! ,x ,(lift-symbol e env)))
    ((let ,bs . ,es)
     `(let ,(map list (map car bs) (lift-symbol-each (map cadr bs) env))
          . ,(lift-symbol-each es env)))
    ((lambda ,params ,variadic? . ,es)
     `(lambda ,params ,variadic? . ,(lift-symbol-each es env)))
    (,() (error "lift-symbol" "unmatch" e))))

(define (lift-symbol-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) . ,es)
     (let* ((syms (collect-symbol-each es))
            (vars (map (lambda (s) (generate-label "sym")) syms))
            (env (extend-env syms (map (lambda (s) `(var ,s)) vars) (make-env)))
            (init-sym (lambda (x) (uniquify `(string->symbol ,(symbol->string x)) (make-env))))
            (inits (map (lambda (x s) (list x (init-sym s))) vars syms)))
      (if (null? inits)
          `(program
            (labels)
            (data . ,data)
            (unbounds . ,unbounds)
            . ,es)
          `(program
            (labels)
            (data . ,data)
            (unbounds . ,unbounds)
            (let ,inits . ,(lift-symbol-each es env))))
      ))
    (,() (error "lift-symbol" "unmatch" prog))))

;;; convert-assignment
(define (uncover-set!-each es)
  (fold-left set-union (make-set) (map uncover-set! es)))

(define (uncover-set! e)
  (match e
    (,()
     (guard (not (pair? e)))
     (make-set))
    ('()
     (make-set))
    ((var ,()) (make-set))
    ((prim ,()) (make-set))
    ((global ,() ,()) (make-set))
    ((global-ref ,() ,()) (make-set))
    ((let ,bs . ,es)
     (set-union (uncover-set!-each (map cadr bs))
                (uncover-set!-each es)))
    ((set! ,x ,e)
     (set-union (make-set x) (uncover-set! e)))
    ((lambda ,() . ,es)
     (uncover-set!-each es))
    ((,form . ,es)
     (guard (member form '(if begin call apply case-lambda)))
     (uncover-set!-each es))
    ((,call ,() . ,es)
     (guard (member call '(foreign-call prim-call)))
     (uncover-set!-each es))
    (,() (error "uncover-set!" "unmatch" e))))

(define (convert-params params set!-vars cont)
  (cond
    ((not (pair? params))
     (cont '() '()))
    ((member (car params) set!-vars)
     (let ((tmp (generate-label (car params))))
      (convert-params (cdr params) set!-vars
        (lambda (params* inits)
          (cont (cons tmp params*)
                (cons `(,(car params) (prim-call cons (var ,tmp) '()))
                      inits))))))
    (else
     (convert-params (cdr params) set!-vars
       (lambda (params* inits)
         (cont (cons (car params) params*) inits))))))

(define (convert-assignment-each es set!-vars)
  (if (pair? es)
      (cons (convert-assignment (car es) set!-vars)
            (convert-assignment-each (cdr es) set!-vars))
      '()))

(define (convert-assignment e set!-vars)
  (match e
    (,()
     (guard (not (pair? e)))
     e)
    ('() e)
    ((var ,x)
     (if (member x set!-vars)
         `(prim-call car ,e)
         e))
    ((prim ,()) e)
    ((global ,() ,()) `(prim-call car ,e))
    ((global-ref ,lbl ,ori) `(global ,lbl ,ori))
    ((set! ,x ,e)
     `(prim-call set-car! (var ,x) ,(convert-assignment e set!-vars)))
    ((case-lambda . ,clauses)
     `(case-lambda
        . ,(convert-assignment-each clauses set!-vars)))
    ((lambda ,params ,variadic? . ,es)
     (convert-params params set!-vars
      (lambda (params inits)
        (if (pair? inits)
            `(lambda ,params ,variadic? (let ,inits . ,(convert-assignment-each es set!-vars)))
            `(lambda ,params ,variadic? . ,(convert-assignment-each es set!-vars))))))
    ((,form . ,es)
     (guard (member form '(if begin call apply)))
     `(,form . ,(convert-assignment-each es set!-vars)))
    ((let ,bs . ,es)
     (let ((convert-binding
            (lambda (b)
             (let ((init (convert-assignment (cadr b) set!-vars)))
              (if (member (car b) set!-vars)
                 `(,(car b) (prim-call cons ,init '()))
                 `(,(car b) ,init))))))
        `(let ,(map convert-binding bs)
              . ,(convert-assignment-each es set!-vars))))
    ((,call ,fn . ,es)
     (guard (member call '(foreign-call prim-call)))
     `(,call ,fn . ,(convert-assignment-each es set!-vars)))
    (,() (error "convert-assignment" "unmatch" e))))

(define (convert-assignment-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) . ,es)
     (let* ((set!-vars (uncover-set!-each es)))
        `(program
          (labels)
          (data . ,data)
          (unbounds . ,unbounds)
          . ,(convert-assignment-each es set!-vars))))
    (,() (error "convert-assignment-program" "unmatch" prog))))

;;; explicate-control
(define (explicate-each es tail?)
  (cond
    ((null? es) '())
    ((not (pair? (cdr es)))
     (list (explicate-control (car es) tail?)))
    (else
     (cons (explicate-control (car es) #f)
           (explicate-each (cdr es) tail?)))))

(define (explicate-control e tail?)
  (match e
    (,()
     (guard (not (pair? e)))
     e)
    ('() e)
    ((var ,()) e)
    ((prim ,()) e)
    ((global ,() ,()) e)
    ((let ,bs . ,es)
     `(let
       ,(map (lambda (b)
              (list (car b)
                    (explicate-control (cadr b) #f)))
             bs)
       . ,(explicate-each es tail?)))
    ((if ,pred ,conseq ,altern)
     `(if ,(explicate-control pred #f)
          ,(explicate-control conseq tail?)
          ,(explicate-control altern tail?)))
    ((begin . ,es)
     `(begin . ,(explicate-each es tail?)))
    ((,call ,fn . ,es)
     (guard (member call '(prim-call foreign-call)))
     `(,call ,fn . ,(explicate-each es #f)))
    ((call ,fn . ,es)
     (let ((fn (explicate-control fn #f))
           (es (explicate-each es #f)))
        (if tail?
            `(tail-call ,fn . ,es)
            `(call ,fn . ,es))))
    ((lambda ,params ,variadic? . ,es)
     `(lambda ,params ,variadic? . ,(explicate-each es #t)))
    ((case-lambda . ,clauses)
     `(case-lambda
        . ,(explicate-each clauses #t)))
    ((apply ,fn ,es)
     (let ((fn (explicate-control fn #f))
           (es (explicate-each es #f)))
        (if tail?
            `(tail-apply ,fn ,es)
            `(apply ,fn ,es))))
    (,() (error "explicate-control" "unmatch" e))))

(define (explicate-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) . ,es)
     `(program (labels) (data . ,data) (unbounds . ,unbounds)
        . ,(explicate-each es #f)))
    (,() (error "explicate-program" "unmatch" prog))))

;;; uncover-free-program
(define (free-vars-each es)
  (fold-left set-union (make-set) (map free-vars es)))

(define (free-vars-lambda params body)
  (set-diff (free-vars-each body) params))

(define (free-vars e)
  (match e
    (,()
     (guard (not (pair? e)))
     (make-set))
    ('() (make-set))
    ((var ,x) (make-set x))
    ((prim ,()) (make-set))
    ((global ,() ,()) (make-set))
    ((let ,bs . ,es)
     (set-union (free-vars-each (map cadr bs))
                (set-diff (free-vars-each es) (map car bs))))
    ((lambda ,params ,variadic? . ,body)
     (free-vars-lambda params body))
    ((,form . ,es)
     (guard (member form '(call tail-call if begin apply tail-apply)))
     (free-vars-each es))
    ((,form ,fn . ,es)
     (guard (member form '(prim-call foreign-call)))
     (free-vars-each es))
    (,() (error "free-vars" "unmatch" e))))

;;; uncover-free-program
(define (uncover-free-each es)
  (map uncover-free es))

(define (uncover-free e)
  (match e
    (,()
     (guard (not (pair? e)))
     e)
    ('() e)
    ((var ,()) e)
    ((prim ,()) e)
    ((global ,() ,()) e)
    ((lambda ,params ,variadic? . ,body)
     `(lambda ,params ,variadic? ,(free-vars-lambda params body) . ,(uncover-free-each body)))
    ((case-lambda . ,clauses)
     `(case-lambda ,(free-vars-each clauses) . ,(uncover-free-each clauses)))
    ((let ,bs . ,es)
     `(let ,(map list (map car bs) (uncover-free-each (map cadr bs)))
        . ,(uncover-free-each es)))
    ((,form . ,es)
     (guard (member form '(call tail-call if begin apply tail-apply)))
     `(,form . ,(uncover-free-each es)))
    ((,form ,fn . ,es)
     (guard (member form '(prim-call foreign-call)))
     `(,form ,fn . ,(uncover-free-each es)))
    (,() (error "uncover-free" "unmatch" e))))

(define (uncover-free-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) . ,es)
     `(program (labels) (data . ,data) (unbounds . ,unbounds) . ,(uncover-free-each es)))
    (,() (error "uncover-free-program" "unmatch" prog))))

;;; convert-closure+reveal-function
(define (reveal-function-each es cont)
  (if (pair? es)
      (reveal-function (car es)
        (lambda (e codes-1)
          (reveal-function-each (cdr es)
            (lambda (es codes-2)
              (cont (cons e es)
                    (append codes-1 codes-2))))))
      (cont '() '())))

(define (reveal-function-function params variadic? fvs body cont)
  (let ((clos (generate-label "clos"))
        (fn (generate-label "lambda")))
    (reveal-function-each body
      (lambda (body codes)
        (cont `(closure ,fn ,fvs)
              (cons `(,fn (code (,clos . ,params) ,variadic? ,fvs . ,body))
                    codes))))))

(define (reveal-function e cont)
  (match e
    (,()
     (guard (not (pair? e)))
     (cont e '()))
    ('() (cont e '()))
    ((var ,()) (cont e '()))
    ((prim ,()) (cont e '()))
    ((global ,() ,()) (cont e '()))
    ((lambda ,params ,variadic? ,fvs . ,body)
     (reveal-function-function params variadic? fvs body cont))
    ((case-lambda ,fvs . ,clauses)
     (define (extract-info c)
      (match c
        ((lambda ,params ,variadic? ,fvs . ,())
         (list (add1 (length params)) variadic?))
        (,() (error "reveal-function" "extract-info:expect-lambda" c))))
     (define infos (map extract-info clauses))
     (define fn (generate-label "case_lambda"))
     (reveal-function-each clauses
      (lambda (clauses codes)
        (cont
          `(closure ,fn ,fvs)
          (cons `(,fn (case-code
                        ,fvs
                        . ,(map append infos clauses)))
                codes)))))
    ((let ,bs . ,es)
     (reveal-function-each (map cadr bs)
      (lambda (inits codes-1)
        (reveal-function-each es
          (lambda (es codes-2)
            (cont `(let ,(map list (map car bs) inits) . ,es)
                  (append codes-1 codes-2)))))))
    ((,form . ,es)
     (guard (member form '(call tail-call if begin apply tail-apply)))
     (reveal-function-each es
      (lambda (es codes)
        (cont `(,form . ,es) codes))))
    ((,form ,fn . ,es)
     (guard (member form '(prim-call foreign-call)))
     (reveal-function-each es
      (lambda (es codes)
        (cont `(,form ,fn . ,es)
              codes))))
    (,() (error "reveal-function" "unmatch" e))))

(define (reveal-function-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) . ,es)
     (reveal-function-each es
      (lambda (es codes)
        `(program (labels . ,codes) (data . ,data) (unbounds . ,unbounds) . ,es))))
    (,() (error "reveal-function-program" "unmatch" prog))))

(define (preprocess passes prog)
  (if (pair? passes)
      (preprocess (cdr passes) ((car passes) prog))
      prog))

