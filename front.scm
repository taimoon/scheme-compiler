(import
  (only (match) match)
  (only (set) make-set set-union set-diff)
  (only (desugar)
    immediate? make-begin make-let uniquify-program)
  (only (utils)
    make-env extend-env extend-env* maybe-apply-env apply-env
    read-sexps-from-path align-to-multiple generate-label
    symbol->id-symbol)
  (only (tmp-alloc) assign-home-program lower-let-program))

(define preprocess (let ()
;;; collect-quote
(define (collect-quote-each es)
  (fold-left set-union (make-set) (map collect-quote es)))

(define (collect-quote e)
  (match e
    (,()
     (guard (immediate? e))
     (make-set))
    (,()
     (guard (string? e))
     (make-set e))
    (,()
     (guard (symbol? e))
     (make-set))
    ((,form ,())
     (guard (memq form '(global label prim)))
     (make-set))
    ((quote ())
     (make-set))
    ((quote ,e)
     (if (symbol? e)
         (make-set)
         (make-set e)))
    ((,form . ,es)
     (guard (memq form '(if begin call)))
     (collect-quote-each es))
    ((,form ,() . ,es)
     (guard (memq form '(foreign-call case-lambda)))
     (collect-quote-each es))
    ((set! ,() ,e)
     (collect-quote e))
    ((lambda ,() ,() ,() ,e)
     (collect-quote e))
    ((let ,bs ,e)
     (set-union (collect-quote e)
                (collect-quote-each (map cadr bs))))
    ((letrec ,bs ,e)
     (set-union (collect-quote e)
                (collect-quote-each (map cadr bs))))
    (,() (error "collect-quote" "unmatch" e))))

(define (lift-quote-each es env)
  (map (lambda (e) (lift-quote e env)) es))

(define (lift-quote e env)
  (match e
    (,()
     (guard (immediate? e))
     e)
    (,()
     (guard (string? e))
     (apply-env e env))
    (,()
     (guard (symbol? e))
     e)
    ((quote ())
     e)
    ((quote ,e*)
     (if (symbol? e*)
         e
         (apply-env e* env)))
    ((prim ,())
     e)
    ((global ,()) e)
    ((,form . ,es)
     (guard (memq form '(if begin call)))
     `(,form . ,(lift-quote-each es env)))
    ((,form ,fn . ,es)
     (guard (memq form '(foreign-call case-lambda)))
     `(,form ,fn . ,(lift-quote-each es env)))
    ((set! ,x ,e)
     `(set! ,x ,(lift-quote e env)))
    ((let ,bs ,e)
     `(let ,(map list (map car bs) (lift-quote-each (map cadr bs) env))
           ,(lift-quote e env)))
    ((letrec ,bs ,e)
     `(letrec ,(map list (map car bs) (lift-quote-each (map cadr bs) env))
              ,(lift-quote e env)))
    ((lambda ,params ,variadic? ,fn ,e)
     `(lambda ,params ,variadic? ,fn ,(lift-quote e env)))
    (,() (error "lift-quote" "unmatch" e))))

(define (lift-quote-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) ,e)
     (let* ((constexps (collect-quote e))
            (lbls (map (lambda (_) (generate-label "const")) constexps))
            (env (extend-env constexps (map (lambda (lbl) `(label ,lbl)) lbls) (make-env)))
            (inits (map (lambda (lbl e) `(set-label! ,lbl ,e)) lbls constexps)))
      (if (null? inits)
          `(program
            (labels)
            (data . ,data)
            (unbounds . ,unbounds)
            ,e)
          `(program
            (labels)
            (data ,@data ,@lbls)
            (unbounds . ,unbounds)
            ,(make-begin (append inits (list (lift-quote e env))))))))
    (,() (error "lift-quote-program" "unmatch" prog))))

;;; collect-symbol
(define (collect-symbol-each es)
  (fold-left set-union (make-set) (map collect-symbol es)))

(define (collect-symbol e)
  (match e
    (,()
     (guard (immediate? e))
     (make-set))
    (,()
     (guard (string? e))
     (make-set))
    (,()
     (guard (symbol? e))
     (make-set))
    ((,form ,())
     (guard (memq form '(global label prim)))
     (make-set))
    ((quote ())
     (make-set))
    ((quote ,x)
     (guard (symbol? x))
     (make-set x))
    ((,form . ,es)
     (guard (memq form '(if begin call)))
     (collect-symbol-each es))
    ((,form ,() . ,es)
     (guard (memq form '(foreign-call case-lambda)))
     (collect-symbol-each es))
    ((,assgn-form ,() ,e)
     (guard (memq assgn-form '(set! set-label!)))
     (collect-symbol e))
    ((lambda ,() ,() ,() ,e)
     (collect-symbol e))
    ((let ,bs ,e)
     (set-union (collect-symbol e)
                (collect-symbol-each (map cadr bs))))
    ((letrec ,bs ,e)
     (set-union (collect-symbol e)
                (collect-symbol-each (map cadr bs))))
    (,() (error "collect-symbol" "unmatch" e))))

(define (lift-symbol-each es env)
  (map (lambda (e) (lift-symbol e env)) es))

(define (lift-symbol e env)
  (match e
    (,()
     (guard (immediate? e))
     e)
    (,()
     (guard (string? e))
     e)
    (,()
     (guard (symbol? e))
     e)
    ((quote ())
     e)
    ((quote ,x)
     (guard (symbol? x))
     (apply-env x env))
    ((,form ,())
     (guard (memq form '(global label prim)))
     e)
    ((,form . ,es)
     (guard (memq form '(if begin call)))
     `(,form . ,(lift-symbol-each es env)))
    ((,form ,fn . ,es)
     (guard (memq form '(foreign-call case-lambda)))
     `(,form ,fn . ,(lift-symbol-each es env)))
    ((,assgn-form ,x ,e)
     (guard (memq assgn-form '(set! set-label!)))
     `(,assgn-form ,x ,(lift-symbol e env)))
    ((let ,bs ,e)
     `(let ,(map list (map car bs) (lift-symbol-each (map cadr bs) env))
           ,(lift-symbol e env)))
    ((letrec ,bs ,e)
     `(letrec ,(map list (map car bs) (lift-symbol-each (map cadr bs) env))
              ,(lift-symbol e env)))
    ((lambda ,params ,variadic? ,fn ,e)
     `(lambda ,params ,variadic? ,fn ,(lift-symbol e env)))
    (,() (error "lift-symbol" "unmatch" e))))

(define (lift-symbol-program prog)
  (define (init-sym x)
    #;(string->symbol ,(symbol->string x))
    `(call #f ,(make-prim-call 'car `(global ,(symbol->id-symbol 'string->symbol)))
      ,(symbol->string x)))
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) ,e)
     (let* ((syms (collect-symbol e))
            (lbls (map (lambda (_) (generate-label "sym")) syms))
            (env (extend-env syms (map (lambda (lbl) `(label ,lbl)) lbls) (make-env)))
            (inits (map (lambda (lbl s) `(set-label! ,lbl ,(init-sym s))) lbls syms)))
      (if (null? inits)
          `(program
            (labels)
            (data . ,data)
            (unbounds . ,unbounds)
            ,e)
          `(program
            (labels)
            (data ,@data ,@lbls)
            (unbounds . ,unbounds)
            ,(make-begin (append inits (list (lift-symbol e env))))))))
    (,() (error "lift-symbol-program" "unmatch" prog))))

(define (constant-folding-each es env set!-vars)
  (map (lambda (e) (constant-folding e env set!-vars)) es))

(define foldable-primitives
  `(
    (+ ,+)
    (* ,*)
    (- ,(case-lambda ((n) (- 0 n)) ((n m) (- n m))))
    (char->integer ,char->integer)
    (integer->char ,integer->char)
    (char? ,char?)
    (boolean? ,boolean?)
    (integer? ,integer?)
    (< ,<)
    (<= ,<=)
    (= ,=)
    (> ,>)
    (>= ,>=)
    (eq? ,eq?)
    (div ,div)
    (mod ,mod)
    (procedure? ,procedure?)
    (bitwise-ior ,bitwise-ior)
    (bitwise-and ,bitwise-and)
    ))

(define non-foldable-primitives
  '(vector cons %walk-stack make-string make-vector
    fxmax fxlength fxabs fixnum-width
    eof-object))

(define (constant-folding e env set!-vars)
  (match e
    (,()
     (guard (immediate? e))
     e)
    (,()
     (guard (string? e))
     e)
    (,()
     (guard (symbol? e))
     (apply-env e env))
    ((quote ()) e)
    ((prim ,()) e)
    ((label ,()) e)
    ((global ,()) e)
    ((let ,bs ,e)
     (let loop ((vars (map car bs))
                (inits (constant-folding-each (map cadr bs) env set!-vars))
                (bs '())
                (inner-env env))
        (cond
          ((not (pair? vars))
           (make-let (reverse bs) (constant-folding e inner-env set!-vars)))
          ((not (symbol? (car vars)))
           (error "constant-folding" "handle-only-symbolic-var" (car vars)))
          ((and (not (memq (car vars) set!-vars))
                (or (immediate? (car inits)) (symbol? (car inits))))
           (loop (cdr vars)
                 (cdr inits)
                 bs
                 (extend-env (car vars) (car inits) inner-env)))
          (else
           (loop (cdr vars)
                 (cdr inits)
                 (cons (list (car vars) (car inits)) bs)
                 (extend-env (car vars) (car vars) inner-env))))))
    ((letrec ,bs ,e)
     (define (extend-env-if-immutable vars inits env set!-vars)
      (let recur ((vars vars) (inits inits))
        (cond
          ((not (pair? vars)) env)
          ((not (symbol? (car vars)))
           (error "constant-folding" "handle-only-symbolic-var" (car vars)))
          ((and (not (memq (car vars) set!-vars))
                (immediate? (car inits)))
           (extend-env (car vars) (car inits) (recur (cdr vars) (cdr inits))))
          (else
           (extend-env (car vars) (car vars) (recur (cdr vars) (cdr inits)))))))
     (define (fixpoint-fold-letrec-inits vars inits env set!-vars k)
      (let* ((env* (extend-env-if-immutable vars inits env set!-vars))
             (inits* (constant-folding-each inits env* set!-vars)))
        (if (equal? inits inits*)
            (k vars inits env*)
            (fixpoint-fold-letrec-inits vars inits* env set!-vars k))))
     (define (trim-inits vars inits env set!-vars)
        (let loop ((vars vars) (inits inits) (bs '()))
          (cond
            ((not (pair? vars))
             `(letrec ,(reverse bs) ,(constant-folding e env set!-vars)))
            ((and (not (memq (car vars) set!-vars))
                  (immediate? (car inits)))
             (loop (cdr vars) (cdr inits) bs))
            (else
             (loop (cdr vars) (cdr inits) (cons (list (car vars) (car inits)) bs))))))
     (fixpoint-fold-letrec-inits (map car bs) (map cadr bs) env set!-vars
        (lambda (vars inits env) (trim-inits vars inits env set!-vars))))
    ((,assgn-form ,x ,e)
     (guard (memq assgn-form '(set! set-label!)))
     `(,assgn-form ,x ,(constant-folding e env set!-vars)))
    ((call (prim ,pr) . ,es)
     (let ((es (constant-folding-each es env set!-vars))
           (fn (maybe-apply-env pr foldable-primitives)))
      (cond
        ((or (memq pr non-foldable-primitives)
             (not (andmap immediate? es)))
         `(call (prim ,pr) . ,es))
        ((not (eq? fn #f))
         (apply (cadr fn) es))
        (else
         (error "constant-folding" "prim:unmatch" e)))))
    ((,form . ,es)
     (guard (memq form '(call begin if)))
     `(,form . ,(constant-folding-each es env set!-vars)))
    ((lambda ,params ,variadic? ,fn ,e)
     `(lambda ,params ,variadic? ,fn ,(constant-folding e (extend-env params params env) set!-vars)))
    ((,form ,fn . ,es)
     (guard (memq form '(foreign-call case-lambda)))
     `(,form ,fn . ,(constant-folding-each es env set!-vars)))
    (,() (error "constant-folding" "unmatch" e))))

(define (constant-folding-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) ,e)
     (let ((env (extend-env data data (extend-env unbounds unbounds (make-env)))))
     `(program (labels) (data . ,data) (unbounds . ,unbounds)
        ,(constant-folding e env (uncover-set! e)))))
    (,() (error "constant-folding-program" "unmatch" prog))))

;;; purify-letrec-program
(define (letrec->fix vars inits body set!-vars)
  (define (lambda-expr? e)
    (match e
      ((lambda . ,()) #t)
      ((case-lambda . ,()) #t)
      (,() #f)))
  (define (assigned? x) (if (memq x set!-vars) #t #f))
  (define (partition-binding vars inits cont)
    (if (not (pair? vars))
        (cont '() '())
        (partition-binding (cdr vars) (cdr inits)
          (lambda (procs complexs)
            (cond
              ((assigned? (car vars))
               (cont procs (cons (list (car vars) (car inits)) complexs)))
              ((lambda-expr? (car inits))
               (cont (cons (list (car vars) (car inits)) procs) complexs))
              (else
               (cont procs (cons (list (car vars) (car inits)) complexs))))))))
  (define (make-letrec procs body)
    (if (pair? procs)
        `(letrec ,procs ,body)
        body))
  (define (letrec->fix procs complexs)
    (make-let
      (map (lambda (c) (list (car c) #f)) complexs)
      (make-letrec
        procs
        (make-begin
          (append (map (lambda (b) `(set! . ,b)) complexs) (list body))))))
  (partition-binding vars inits letrec->fix))

(define (purify-letrec-each es set!-vars)
  (map (lambda (e) (purify-letrec e set!-vars)) es))

(define (purify-letrec e set!-vars)
  (let purify-letrec ((e e))
    (match e
      (,()
       (guard (immediate? e))
       e)
      (,()
       (guard (string? e))
       e)
      (,()
       (guard (symbol? e))
       e)
      ((quote ()) e)
      ((,form ,())
       (guard (memq form '(global label prim)))
       e)
      ((set-label! ,lbl ,e)
       `(set-label! ,lbl ,(purify-letrec e)))
      ((set! ,x ,e)
       `(set! ,x ,(purify-letrec e)))
      ((lambda ,params ,variadic? ,fn ,e)
       `(lambda ,params ,variadic? ,fn ,(purify-letrec e)))
      ((let ,bs ,e)
       `(let ,(map (lambda (b) (list (car b) (purify-letrec (cadr b)))) bs)
             ,(purify-letrec e)))
      ((letrec ,bs ,e)
       (letrec->fix
        (map car bs)
        (purify-letrec-each (map cadr bs) set!-vars)
        (purify-letrec e)
        set!-vars))
      ((,form . ,es)
       (guard (memq form '(if begin call)))
       `(,form . ,(purify-letrec-each es set!-vars)))
      ((,form ,fn . ,es)
       (guard (memq form '(foreign-call case-lambda)))
       `(,form ,fn . ,(purify-letrec-each es set!-vars)))
      (,() (error "purify-letrec" "unmatch" e)))))

(define (purify-letrec-program prog)
  (match prog
    ((program ,labels ,data ,unbounds ,e)
     `(program ,labels ,data ,unbounds
        ,(purify-letrec e (uncover-set! e))))
    (,() (error "purify-letrec-program" "unmatch" prog))))

;;; optimize-known-call
(define (extend-labels bs env)
  (if (not (pair? bs))
      env
      (match (car bs)
        ((,x (lambda ,params ,variadic? ,fn ,e))
         (cons (list x (list 'label fn))
               (extend-labels (cdr bs) env)))
        ((,x (case-lambda ,fn . ,clauses))
         (cons (list x (list 'label fn))
               (extend-labels (cdr bs) env)))
        (,()
         (extend-labels (cdr bs) env)))))

(define (maybe-label e env)
  (if (symbol? e)
      (let ((r (maybe-apply-env e env)))
        (if (pair? r)
            (cadr r)
            r))
      #f))

(define (optimize-known-call-each es env)
  (map (lambda (e) (optimize-known-call e env)) es))

(define (optimize-known-call e env)
  (match e
    (,()
     (guard (immediate? e))
      e)
    (,()
     (guard (string? e))
     e)
    (,()
     (guard (symbol? e))
     e)
    ((quote ()) e)
    ((,form ,())
     (guard (memq form '(global label prim)))
     e)
    ((set-label! ,x ,e)
      `(set-label! ,x ,(optimize-known-call e env)))
    ((set! ,x ,e)
      `(set! ,x ,(optimize-known-call e env)))
    ((lambda ,params ,variadic? ,fn ,e)
      `(lambda ,params ,variadic? ,fn ,(optimize-known-call e env)))
    ((let ,bs ,e)
     (let ((bs (map (lambda (b) (list (car b) (optimize-known-call (cadr b) env))) bs))
           (env (extend-labels bs env)))
        `(let ,bs ,(optimize-known-call e env))))
    ((letrec ,bs ,e)
     (let ((env (extend-labels bs env)))
      `(letrec
          ,(map (lambda (b) (list (car b) (optimize-known-call (cadr b) env))) bs)
          ,(optimize-known-call e env))))
    ((call (prim ,pr) . ,es)
     `(call (prim ,pr) . ,(optimize-known-call-each es env)))
    ((call #f ,op . ,es)
     `(call ,(maybe-label op env) . ,(optimize-known-call-each (cons op es) env)))
    ((,form . ,es)
      (guard (memq form '(if begin call)))
      `(,form . ,(optimize-known-call-each es env)))
    ((,form ,fn . ,es)
      (guard (memq form '(foreign-call case-lambda)))
      `(,form ,fn . ,(optimize-known-call-each es env)))
    (,() (error "optimize-known-call" "unmatch" e))))

(define (optimize-known-call-program prog)
  (match prog
    ((program ,labels ,data ,unbounds ,e)
     `(program ,labels ,data ,unbounds
        ,(optimize-known-call e (make-env))))
    (,() (error "optimize-known-call-program" "unmatch" prog))))

;;; convert-letrec
(define (convert-letrec e)
  (match e
    (,()
     (guard (immediate? e))
     e)
    (,()
     (guard (string? e))
     e)
    (,()
     (guard (symbol? e))
     e)
    ((quote ()) e)
    ((,form ,())
     (guard (memq form '(global label prim)))
     e)
    ((set-label! ,x ,e)
      `(set-label! ,x ,(convert-letrec e)))
    ((set! ,x ,e)
      `(set! ,x ,(convert-letrec e)))
    ((lambda ,params ,variadic? ,fn ,e)
      `(lambda ,params ,variadic? ,fn ,(convert-letrec e)))
    ((let ,bs ,e)
      `(let ,(map (lambda (b) (list (car b) (convert-letrec (cadr b)))) bs)
            ,(convert-letrec e)))
    ((letrec ,bs ,e)
     (let ((vars (map car bs))
           (inits (map (lambda (b) (convert-letrec (cadr b))) bs))
           (e (convert-letrec e)))
        (make-let (map (lambda (x) (list x #f)) vars)
                  (make-begin
                    (list (make-begin (map (lambda (x init) (list 'set! x init)) vars inits))
                          e)))))
    ((,form . ,es)
      (guard (memq form '(if begin call)))
      `(,form . ,(map convert-letrec es)))
    ((,form ,fn . ,es)
      (guard (memq form '(foreign-call case-lambda)))
      `(,form ,fn . ,(map convert-letrec es)))
    (,() (error "convert-letrec" "unmatch" e))))

(define (convert-letrec-program prog)
  (match prog
    ((program ,labels ,data ,unbounds ,e)
     `(program ,labels ,data ,unbounds ,(convert-letrec e)))
    (,() (error "convert-letrec-program" "unmatch" prog))))

;;; convert-assignment
(define (uncover-set!-each es)
  (fold-left set-union (make-set) (map uncover-set! es)))

(define (uncover-set! e)
  (match e
    (,()
     (guard (immediate? e))
     (make-set))
    (,()
     (guard (string? e))
     (make-set))
    (,()
     (guard (symbol? e))
     (make-set))
    ((quote ()) (make-set))
    ((,form ,())
     (guard (memq form '(global label prim)))
     (make-set))
    ((let ,bs ,e)
     (set-union (uncover-set!-each (map cadr bs))
                (uncover-set! e)))
    ((letrec ,bs ,e)
     (set-union (uncover-set!-each (map cadr bs))
                (uncover-set! e)))
    ((set! ,x ,e)
     (set-union (make-set x) (uncover-set! e)))
    ((lambda ,() ,() ,() ,e)
     (uncover-set! e))
    ((,form . ,es)
     (guard (memq form '(if begin call)))
     (uncover-set!-each es))
    ((,form ,() . ,es)
     (guard (memq form '(foreign-call case-lambda set-label!)))
     (uncover-set!-each es))
    (,()
     (error "uncover-set!" "unmatch" e))))

(define (make-prim-call pr . es)
  `(call (prim ,pr) . ,es))

(define (make-box-init e)
  (make-prim-call 'cons e '(quote ())))

(define (make-box-ref e)
  (make-prim-call 'car e))

(define (make-box-set! x e)
  (make-prim-call 'set-car! x e))

(define (convert-params params set!-vars cont)
  (cond
    ((not (pair? params))
     (cont '() '()))
    ((member (car params) set!-vars)
     (let ((tmp (generate-label (car params))))
      (convert-params (cdr params) set!-vars
        (lambda (params* inits)
          (cont (cons tmp params*)
                (cons `(,(car params) ,(make-box-init tmp))
                      inits))))))
    (else
     (convert-params (cdr params) set!-vars
       (lambda (params* inits)
         (cont (cons (car params) params*) inits))))))

(define (convert-assignment-each es set!-vars)
  (map (lambda (e) (convert-assignment e set!-vars)) es))

(define (convert-assignment e set!-vars)
  (match e
    (,()
     (guard (immediate? e))
     e)
    (,()
     (guard (string? e))
     e)
    (,()
     (guard (symbol? e))
     (if (member e set!-vars)
         (make-box-ref e)
         e))
    ((quote ()) e)
    ((,form ,())
     (guard (memq form '(global label prim)))
     e)
    ((set-label! ,x ,e)
     `(set-label! ,x ,(convert-assignment e set!-vars)))
    ((set! ,x ,e)
     (make-box-set! x (convert-assignment e set!-vars)))
    ((case-lambda ,fn . ,clauses)
     `(case-lambda ,fn
        . ,(convert-assignment-each clauses set!-vars)))
    ((lambda ,params ,variadic? ,fn ,e)
     (convert-params params set!-vars
      (lambda (params inits)
        `(lambda ,params ,variadic? ,fn ,(make-let inits (convert-assignment e set!-vars))))))
    ((,form . ,es)
     (guard (memq form '(if begin call)))
     `(,form . ,(convert-assignment-each es set!-vars)))
    ((let ,bs ,e)
     (let ((convert-binding
            (lambda (b)
             (let ((init (convert-assignment (cadr b) set!-vars)))
              (if (member (car b) set!-vars)
                 `(,(car b) ,(make-box-init init))
                 `(,(car b) ,init))))))
        `(let ,(map convert-binding bs)
              ,(convert-assignment e set!-vars))))
    ((foreign-call ,fn . ,es)
     `(foreign-call ,fn . ,(convert-assignment-each es set!-vars)))
    (,() (error "convert-assignment" "unmatch" e))))

(define (convert-assignment-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program
        (labels)
        (data . ,data)
        (unbounds . ,unbounds)
        ,(convert-assignment e (uncover-set! e))))
    (,() (error "convert-assignment-program" "unmatch" prog))))

;;; uncover-free-program
(define (free-vars-each es)
  (fold-left set-union (make-set) (map free-vars es)))

(define (free-vars-lambda params body)
  (set-diff (free-vars body) params))

(define (free-vars e)
  (match e
    (,()
     (guard (immediate? e))
     (make-set))
    (,()
     (guard (string? e))
     (make-set))
    (,()
     (guard (symbol? e))
     (make-set e))
    ((quote ()) (make-set))
    ((,form ,())
     (guard (memq form '(global label prim)))
     (make-set))
    ((let ,bs ,e)
     (set-union (free-vars-each (map cadr bs))
                (set-diff (free-vars e) (map car bs))))
    ((lambda ,params ,variadic? ,fn ,body)
     (free-vars-lambda params body))
    ((,form . ,es)
     (guard (memq form '(call if begin)))
     (free-vars-each es))
    ((,form ,fn . ,es)
     (guard (memq form '(foreign-call case-lambda)))
     (free-vars-each es))
    (,() (error "free-vars" "unmatch" e))))

;;; uncover-free-program
(define (uncover-free-each es)
  (map uncover-free es))

(define (uncover-free e)
  (match e
    (,()
     (guard (immediate? e))
     e)
    (,()
     (guard (string? e))
     e)
    (,()
     (guard (symbol? e))
     e)
    ((quote ()) e)
    ((,form ,())
     (guard (memq form '(global label prim)))
     e)
    ((set-label! ,x ,e)
     `(set-label! ,x ,(uncover-free e)))
    ((lambda ,params ,variadic? ,fn ,body)
     `(lambda ,params ,variadic? ,fn ,(free-vars-lambda params body) ,(uncover-free body)))
    ((case-lambda ,fn . ,clauses)
     `(case-lambda ,fn ,(free-vars-each clauses) . ,(uncover-free-each clauses)))
    ((let ,bs ,e)
     `(let ,(map list (map car bs) (uncover-free-each (map cadr bs)))
        ,(uncover-free e)))
    ((,form . ,es)
     (guard (memq form '(call if begin)))
     `(,form . ,(uncover-free-each es)))
    ((foreign-call ,fn . ,es)
     `(foreign-call ,fn . ,(uncover-free-each es)))
    (,() (error "uncover-free" "unmatch" e))))

(define (uncover-free-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program (labels) (data . ,data) (unbounds . ,unbounds) ,(uncover-free e)))
    (,() (error "uncover-free-program" "unmatch" prog))))

;;; convert-closure
(define (convert-closure-each es env)
  (map (lambda (e) (convert-closure e env)) es))

(define (convert-closure-function params variadic? fn fvs body env)
  (let* ((clos (generate-label "clos"))
        (env*
         (extend-env params params
          (extend-env* (map (lambda (i fv) (list fv `(closure-ref ,clos ,i))) (iota (length fvs)) fvs) env))))
    `(lambda (,clos . ,params) ,variadic? ,fn ,(map (lambda (fv) (list fv (apply-env fv env))) fvs) ,(convert-closure body env*))))

(define (convert-closure e env)
  (match e
    (,()
     (guard (immediate? e))
     e)
    (,()
     (guard (string? e))
     e)
    (,()
     (guard (symbol? e))
     (apply-env e env))
    ((quote ()) e)
    ((,form ,())
     (guard (memq form '(global label prim)))
     e)
    ((set-label! ,x ,e)
     `(set-label! ,x ,(convert-closure e env)))
    ((lambda ,params ,variadic? ,fn ,fvs ,body)
     (convert-closure-function params variadic? fn fvs body env))
    ((case-lambda ,fn ,fvs . ,clauses)
     `(case-lambda ,fn
        ,(map (lambda (fv) (apply-env fv env)) fvs)
        .
        ,(convert-closure-each
            clauses
            (extend-env* (map (lambda (i fv) (list fv `(closure-ref () ,i))) (iota (length fvs)) fvs) env))))
    ((let ,bs ,e)
     (let* ((vars (map car bs))
            (inits (convert-closure-each (map cadr bs) env))
            (env (extend-env* (map (lambda (x) (list x x)) (map car bs)) env)))
        `(let ,(map list vars inits) ,(convert-closure e env))))
    ((,form . ,es)
     (guard (memq form '(call if begin)))
     `(,form . ,(convert-closure-each es env)))
    ((foreign-call ,fn . ,es)
     `(foreign-call ,fn . ,(convert-closure-each es env)))
    (,() (error "convert-closure" "unmatch" e))))

(define (convert-closure-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program (labels) (data . ,data) (unbounds . ,unbounds)
        ,(convert-closure e (extend-env data data (make-env)))))
    (,() (error "convert-closure-program" "unmatch" prog))))

;;; reveal and collect function
(define (reveal-function-each es cont)
  (if (pair? es)
      (reveal-function (car es)
        (lambda (e codes-1)
          (reveal-function-each (cdr es)
            (lambda (es codes-2)
              (cont (cons e es)
                    (append codes-1 codes-2))))))
      (cont '() '())))

(define (reveal-function-function params variadic? fn fvs body cont)
    (reveal-function body
      (lambda (body codes)
        (cont `(closure ,fn ,(map cadr fvs))
                (cons `(,fn (code ,params ,variadic? ,(map car fvs) ,body))
                      codes)))))

(define (reveal-function e cont)
  (match e
    (,()
     (guard (immediate? e))
     (cont e '()))
    (,()
     (guard (string? e))
     (cont e '()))
    (,()
     (guard (symbol? e))
     (cont e '()))
    ((closure-ref ,() ,()) (cont e '()))
    ((quote ()) (cont e '()))
    ((,form ,())
     (guard (memq form '(global label prim)))
     (cont e '()))
    ((set-label! ,x ,e)
     (reveal-function e
      (lambda (e codes)
        (cont `(set-label! ,x ,e) codes))))
    ((lambda ,params ,variadic? ,fn ,fvs ,body)
     (reveal-function-function params variadic? fn fvs body cont))
    ((case-lambda ,fn ,fvs . ,clauses)
     (reveal-function-each clauses
      (lambda (clauses* codes)
        (define (extract-info c)
          (match c
            ((lambda ,params ,variadic? ,fn ,fvs . ,())
             (list variadic? (length params)))
            (,() (error "reveal-function" "extract-info:expect-lambda" c))))
        (let ((infos (map extract-info clauses)))
          (cont
            `(closure ,fn ,fvs)
            (cons `(,fn (case-code () . ,(map append clauses* infos)))
                  codes))))))
    ((let ,bs ,e)
     (reveal-function-each (map cadr bs)
      (lambda (inits codes-1)
        (reveal-function e
          (lambda (e codes-2)
            (cont `(let ,(map list (map car bs) inits) ,e)
                  (append codes-1 codes-2)))))))
    ((,form . ,es)
     (guard (memq form '(call if begin)))
     (reveal-function-each es
      (lambda (es codes)
        (cont `(,form . ,es) codes))))
    ((foreign-call ,fn . ,es)
     (reveal-function-each es
      (lambda (es codes)
        (cont `(foreign-call ,fn . ,es)
              codes))))
    (,() (error "reveal-function" "unmatch" e))))

(define (reveal-function-program prog)
  (match prog
    ((program (labels) (data . ,data) (unbounds . ,unbounds) ,e)
     (reveal-function e
      (lambda (e codes)
        `(program (labels . ,codes) (data . ,data) (unbounds . ,unbounds) ,e))))
    (,() (error "reveal-function-program" "unmatch" prog))))

(define (expand-operand-prim e)
  (match e
    (,()
     (guard (or (string? e) (simple? e)))
     e)
    ((prim ,pr)
     (make-prim-call 'car `(global ,(symbol->id-symbol pr))))
    ((call ,pr/fn/nil . ,es)
     `(call ,pr/fn/nil . ,(map expand-operand-prim es)))
    ((set-label! ,x ,e)
     `(set-label! ,x ,(expand-operand-prim e)))
    ((foreign-call ,fn . ,es)
     `(foreign-call ,fn . ,(map expand-operand-prim es)))
    ((let ,bs ,e)
     `(let ,(map (lambda (b) (list (car b) (expand-operand-prim (cadr b)))) bs)
        ,(expand-operand-prim e)))
    ((,form . ,es)
     (guard (memq form '(begin if)))
     `(,form . ,(map expand-operand-prim es)))
    ((code ,params ,fvs ,variadic? ,e)
     `(code ,params ,fvs ,variadic? ,(expand-operand-prim e)))
    ((,form . ,())
     (guard (memq form '(case-code closure closure-ref)))
     e)
    (,() (error "expand-operand-prim" "unmatch" e))))

(define (expand-operand-prim-program prog)
  (match prog
    ((program (labels . ,codes) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program
        (labels . ,(map (lambda (c) (list (car c) (expand-operand-prim (cadr c)))) codes))
        (data . ,data)
        (unbounds . ,unbounds)
        ,(expand-operand-prim e)))
    (,() (error "expand-operand-prim-program" "unmatch" prog))))


;;; remove-complex-operand
#|
The rco doesn't do eliminate all context like in anf or cps conversion.
Purpose the rco here is to simplify the operands of operation that will allocate memory.
This is to ease expose-alloc pass.
|#

(define (simple? e)
  (or (integer? e) (boolean? e) (char? e) (symbol? e)
      (match e
        ((,form ,())
         (or (eq? form 'label)
             (eq? form 'global)
             (eq? form 'quote)))
        (,() #f))))

(define (rco-named es* k)
  (let loop ((es* es*) (bs '()) (acm '()))
    (cond
      ((not (pair? es*))
       (make-let bs (k (reverse acm))))
      ((simple? (car es*))
       (loop (cdr es*) bs (cons (car es*) acm)))
      (else
       (let ((tmp (generate-label "v")))
        (loop (cdr es*)
              (cons (list tmp (car es*)) bs)
              (cons tmp acm)))))))

(define (rco e)
  (match e
    (,()
     (guard (simple? e))
     e)
    (,()
     (guard (string? e))
     e)
    ((let ,bs ,e)
     `(let ,(map (lambda (b) (list (car b) (rco (cadr b)))) bs)
        ,(rco e)))
    ((set-label! ,x ,e)
     `(set-label! ,x ,(rco e)))
    ((call ,pr/fn/nil . ,es)
     (match pr/fn/nil
      ((prim ,pr)
       (if (memq pr '(make-string make-vector cons vector))
           (rco-named (map rco es)
              (lambda (es) `(call (prim ,pr) . ,es)))
           `(call (prim ,pr) . ,(map rco es))))
      ((label ,())
       `(call ,pr/fn/nil . ,(map rco es)))
      (#f
       `(call #f . ,(map rco es)))
      (,() (error "rco" "unknown:call-header" pr/fn/nil))))
    ((code ,params ,variadic? ,fn ,e)
     `(code ,params ,variadic? ,fn ,(rco e)))
    ((case-code . ,())
     e)
    ((closure . ,())
     e)
    ((closure-ref . ,())
     e)
    ((foreign-call ,fn . ,es)
     `(foreign-call ,fn . ,(map rco es)))
    ((,form . ,es)
     (guard (memq form '(if begin)))
     `(,form . ,(map rco es)))
    (,() (error "rco" "unmatch" e))))

(define (remove-complex-operand-program prog)
  (match prog
    ((program (labels . ,codes) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program (labels . ,(map (lambda (c) (list (car c) (rco (cadr c)))) codes)) (data . ,data) (unbounds . ,unbounds) ,(rco e)))
    (,() (error "remove-complex-operand-program" "unmatch" prog))))

;;; anf-of
(define (identity x) x)

(define (anf-of-exps es k)
  ;;; first version implies that es can be evaluated concurrently
  #;
  (let loop ((es es)
             (bs '())
             (es* '()))
    (cond
      ((not (pair? es))
       (make-let bs (k (reverse es*))))
      ((simple? (car es))
       (loop (cdr es) bs (cons (car es) es*)))
      (else
       (anf-of (car es)
        (lambda (e)
          (let ((tmp (generate-label "v")))
            (loop (cdr es) (cons (list tmp e) bs) (cons tmp es*))))))))
  (let loop ((es es) (es* '()))
    (cond
      ((not (pair? es))
       (k (reverse es*)))
      (else
       (named-anf-of (car es)
        (lambda (e*) (loop (cdr es) (cons e* es*))))))))

(define (anf-of-let bs e k)
  (let loop ((bs bs)
             (bs* '()))
    (cond
      ((not (pair? bs))
       (make-let bs* (anf-of e k)))
      ((simple? (cadr (car bs)))
       (loop (cdr bs) (cons (car bs) bs*)))
      (else
        (anf-of (cadr (car bs))
          (lambda (e)
            `(let ((,(car (car bs)) ,e))
              ,(loop (cdr bs) bs*))))))))

(define (anf-of-seq es k)
  (let recur ((e (car es)) (es (cdr es)))
    (if (not (pair? es))
        (anf-of e k)
        (anf-of e
          (lambda (e)
            `(let ((_ ,e))
                ,(recur (car es) (cdr es))))))))

(define (anf-intro-name e k)
  (let ((tmp (generate-label "v")))
    `(let ((,tmp ,e))
      ,(k tmp))))

(define (named-anf-of e k)
  (if (simple? e)
      (k e)
      (anf-of e (lambda (e) (anf-intro-name e k)))))

(define (anf-of e k)
  (match e
    (,()
     (guard (simple? e))
     (k e))
    (,()
     (guard (string? e))
     (k e))
    ((closure ,fn ,fvs)
     (anf-of-exps fvs
      (lambda (fvs) (k `(closure ,fn ,fvs)))))
    ((closure-ref ,clos ,i)
     (guard (and (simple? clos) (simple? i)))
     (k e))
    ((case-code . ,())
     (k e))
    ((code ,params ,variadic? ,fn ,e)
     `(code ,params ,variadic? ,fn ,(anf-of e identity)))
    ((call (prim ,pr) . ,es)
     (anf-of-exps es
      (lambda (es) (k `(call (prim ,pr) . ,es)))))
    ((call ,maybe-decl . ,es)
     (anf-of-exps es
      (lambda (es) (k `(call ,maybe-decl . ,es)))))
    ((foreign-call ,fn . ,es)
     (anf-of-exps es
      (lambda (es) (k `(foreign-call ,fn . ,es)))))
    ((set-label! ,x ,e)
     (named-anf-of e
      (lambda (e) (k `(set-label! ,x ,e)))))
    ((let ,bs ,e)
     (anf-of-let bs e k))
    ((collect ,sz)
     (named-anf-of sz (lambda (sz) (k `(collect ,sz)))))
    ((begin . ,es)
     (anf-of-seq es k))
    ((if ,pred ,conseq ,altern)
     (let ((conseq (anf-of conseq identity))
           (altern (anf-of altern identity)))
        (named-anf-of pred
          (lambda (pred) (k `(if ,pred ,conseq ,altern))))))
    (,() (error "anf-of" "unmatch" e))))

(define (anf-of-program prog)
  (match prog
    ((program (labels . ,codes) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program
        (labels . ,(map (lambda (c) (list (car c) (anf-of (cadr c) identity))) codes))
        (data . ,data)
        (unbounds . ,unbounds)
        ,(anf-of e identity)))
    (,() (error "expose-alloc-program" "unmatch" prog))))

;;; sequentialize
(define (sequentialize e)
  (match e
    (,()
     (guard (or (simple? e) (string? e)))
     e)
    ((prim ,())
     e)
    ((let ((,x ,e1)) ,e2)
     `(let ((,x ,(sequentialize e1))) ,(sequentialize e2)))
    ((let (,b . ,bs) ,e)
     (sequentialize `(let (,b) (let ,bs ,e))))
    ((,form . ,es)
     (guard (memq form '(collect call if apply)))
     `(,form . ,(map sequentialize es)))
    ((foreign-call ,fn . ,es)
     `(foreign-call ,fn . ,(map sequentialize es)))
    ((code ,params ,variadic? ,fvs ,e)
     `(code ,params ,variadic? ,fvs ,(sequentialize e)))
    ((set-label! ,x ,e)
     `(set-label! ,x ,(sequentialize e)))
    ((,form . ,())
     (guard (memq form '(closure closure-ref case-code)))
     e)
    (,() (error "sequentialize" "unmatch" e))))

(define (sequentialize-program prog)
  (match prog
    ((program (labels . ,codes) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program
        (labels .
          ,(map (lambda (c) (list (car c) (sequentialize (cadr c)))) codes))
        (data . ,data)
        (unbounds . ,unbounds)
        ,(sequentialize e)))
    (,() (error "sequentialize-program" "unmatch" prog))))

;;; expose allocation
(define WORDSIZE 8)

(define (expose-alloc e)
  (match e
    (,()
     (guard (simple? e))
     e)
    (,()
     (guard (string? e))
     `(begin
        (collect ,(align-to-multiple 8 (+ WORDSIZE (add1 (string-length e)))))
        ,e))
    ((let ,bs ,e)
     `(let ,(map (lambda (b) (list (car b) (expose-alloc (cadr b)))) bs)
        ,(expose-alloc e)))
    ((call (prim ,pr) . ,es)
     (match (cons pr es)
      ((vector . ,es)
       `(begin
          (collect
            ,(align-to-multiple 8 (* WORDSIZE (add1 (length es)))))
          (call (prim vector) . ,es)))
      ((make-vector ,sz)
       `(begin
          (collect
            ,(make-prim-call 'align-to-multiple 8
              (make-prim-call '* WORDSIZE (make-prim-call '+ 1 sz))))
          (call (prim make-vector) ,sz)))
      ((make-string ,sz ,ch)
        `(begin
              (collect
                ,(make-prim-call 'align-to-multiple 8
                  (make-prim-call '+ WORDSIZE (make-prim-call '+ 1 sz))))
                  (call (prim make-string) ,sz ,ch)))
      ((cons . ,es)
       `(begin
          (collect ,(* 2 WORDSIZE))
          (call (prim cons) . ,es)))
      ((,pr . ,es) `(call (prim ,pr) . ,(map expose-alloc es)))))
    ((call ,maybe-decl . ,es)
     `(call ,maybe-decl . ,(map expose-alloc es)))
    ((set-label! ,x ,e)
     `(set-label! ,x ,(expose-alloc e)))
    ((code ,params ,variadic? ,fvs ,e)
     `(code ,params ,variadic? ,fvs ,(expose-alloc e)))
    ((case-code . ,())
     e)
    ((closure ,lbl ,fvs)
     `(begin
        (collect ,(align-to-multiple 8 (* WORDSIZE (+ 2 (length fvs)))))
        ,e))
    ((closure-ref ,clos ,i)
     e)
    ((foreign-call ,fn . ,es)
     `(foreign-call ,fn . ,(map expose-alloc es)))
    ((,form . ,es)
     (guard (memq form '(if begin)))
     `(,form . ,(map expose-alloc es)))
    (,() (error "expose-alloc" "unmatch" e))))

(define (expose-alloc-program prog)
  (match prog
    ((program (labels . ,codes) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program
        (labels . ,(map (lambda (c) (list (car c) (expose-alloc (cadr c)))) codes))
        (data . ,data)
        (unbounds . ,unbounds)
        ,(expose-alloc e)))
    (,() (error "expose-alloc-program" "unmatch" prog))))

;;; explicate-control
(define (explicate-each es tail?)
  (cond
    ((null? es) '())
    ((not (pair? (cdr es)))
     (list (explicate-control (car es) tail?)))
    (else
     (cons (explicate-control (car es) #f)
           (explicate-each (cdr es) tail?)))))

(define (explicate-control e tail?)
  (match e
    (,()
     (guard (simple? e))
     e)
    (,()
     (guard (string? e))
     e)
    ((let ,bs ,e)
     `(let
       ,(map (lambda (b)
              (list (car b)
                    (explicate-control (cadr b) #f)))
             bs)
       ,(explicate-control e tail?)))
    ((if ,pred ,conseq ,altern)
     `(if ,(explicate-control pred #f)
          ,(explicate-control conseq tail?)
          ,(explicate-control altern tail?)))
    ((begin . ,es)
     `(begin . ,(explicate-each es tail?)))
    ((foreign-call ,fn . ,es)
     `(foreign-call ,fn . ,(explicate-each es #f)))
    ((call (prim ,pr) . ,es)
     `(call ,tail? (prim ,pr) . ,(explicate-each es #f)))
    ((call . ,es)
     `(call ,tail? . ,(explicate-each es #f)))
    ((set-label! ,x ,e)
     `(set-label! ,x ,(explicate-control e #f)))
    ((code ,params ,variadic? ,fvs ,e)
     `(code ,params ,variadic? ,fvs ,(explicate-control e #t)))
    ((case-code ,fvs . ,clauses) e)
    ((closure ,fn ,fvs) e)
    ((closure-ref ,clos ,i) e)
    ((collect ,sz)
     `(collect ,(explicate-control sz #f)))
    (,() (error "explicate-control" "unmatch" e))))

(define (explicate-program prog)
  (match prog
    ((program (labels . ,codes) (data . ,data) (unbounds . ,unbounds) ,e)
     `(program
        (labels . ,(map (lambda (c) (list (car c) (explicate-control (cadr c) #t))) codes))
        (data . ,data)
        (unbounds . ,unbounds)
        ,(explicate-control e #f)))
    (,() (error "explicate-program" "unmatch" prog))))

(define (apply-passes prog . passes)
  (fold-left (lambda (prog f) (f prog)) prog passes))

(define (trace-pass name)
  (lambda (e) (format #t "~a:\n" name) (pretty-print e) e))

(define (preprocess prog)
  (apply-passes
    prog
    (trace-pass 'prog)
    uniquify-program
    (trace-pass 'uniquify-program)
    lift-quote-program
    (trace-pass 'lift-quote-program)
    lift-symbol-program
    (trace-pass 'lift-symbol-program)
    constant-folding-program
    (trace-pass 'constant-folding-program)
    purify-letrec-program
    (trace-pass 'purify-letrec-program)
    optimize-known-call-program
    (trace-pass 'optimize-known-call-program)
    convert-letrec-program
    (trace-pass 'convert-letrec-program)
    convert-assignment-program
    (trace-pass 'convert-assignment-program)
    uncover-free-program
    (trace-pass 'uncover-free-program)
    convert-closure-program
    (trace-pass 'convert-closure-program)
    reveal-function-program
    (trace-pass 'reveal-function-program)
    expand-operand-prim-program
    (trace-pass 'expand-operand-prim-program)
    remove-complex-operand-program
    (trace-pass 'remove-complex-operand-program)
    expose-alloc-program
    (trace-pass 'expose-alloc-program)
    anf-of-program
    (trace-pass 'anf-of-program)
    sequentialize-program
    (trace-pass 'sequentialize-program)
    explicate-program
    (trace-pass 'explicate-program)
    assign-home-program
    (trace-pass 'assign-home-program)
    lower-let-program
    (trace-pass 'lower-let-program)
    ))
preprocess))